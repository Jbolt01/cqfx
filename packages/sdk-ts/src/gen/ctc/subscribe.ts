// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from "flatbuffers";

export class Subscribe implements flatbuffers.IUnpackableObject<SubscribeT> {
	bb: flatbuffers.ByteBuffer | null = null;
	bb_pos = 0;
	__init(i: number, bb: flatbuffers.ByteBuffer): Subscribe {
		this.bb_pos = i;
		this.bb = bb;
		return this;
	}

	static getRootAsSubscribe(
		bb: flatbuffers.ByteBuffer,
		obj?: Subscribe,
	): Subscribe {
		return (obj || new Subscribe()).__init(
			bb.readInt32(bb.position()) + bb.position(),
			bb,
		);
	}

	static getSizePrefixedRootAsSubscribe(
		bb: flatbuffers.ByteBuffer,
		obj?: Subscribe,
	): Subscribe {
		bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
		return (obj || new Subscribe()).__init(
			bb.readInt32(bb.position()) + bb.position(),
			bb,
		);
	}

	instruments(index: number): number | null {
		const offset = this.bb!.__offset(this.bb_pos, 4);
		return offset
			? this.bb!.readUint32(this.bb!.__vector(this.bb_pos + offset) + index * 4)
			: 0;
	}

	instrumentsLength(): number {
		const offset = this.bb!.__offset(this.bb_pos, 4);
		return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
	}

	instrumentsArray(): Uint32Array | null {
		const offset = this.bb!.__offset(this.bb_pos, 4);
		return offset
			? new Uint32Array(
					this.bb!.bytes().buffer,
					this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
					this.bb!.__vector_len(this.bb_pos + offset),
				)
			: null;
	}

	bookDepth(): number {
		const offset = this.bb!.__offset(this.bb_pos, 6);
		return offset ? this.bb!.readUint16(this.bb_pos + offset) : 0;
	}

	trades(): boolean {
		const offset = this.bb!.__offset(this.bb_pos, 8);
		return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
	}

	positions(): boolean {
		const offset = this.bb!.__offset(this.bb_pos, 10);
		return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
	}

	teamId(): number {
		const offset = this.bb!.__offset(this.bb_pos, 12);
		return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
	}

	static startSubscribe(builder: flatbuffers.Builder) {
		builder.startObject(5);
	}

	static addInstruments(
		builder: flatbuffers.Builder,
		instrumentsOffset: flatbuffers.Offset,
	) {
		builder.addFieldOffset(0, instrumentsOffset, 0);
	}

	static createInstrumentsVector(
		builder: flatbuffers.Builder,
		data: number[] | Uint32Array,
	): flatbuffers.Offset;
	/**
	 * @deprecated This Uint8Array overload will be removed in the future.
	 */
	static createInstrumentsVector(
		builder: flatbuffers.Builder,
		data: number[] | Uint8Array,
	): flatbuffers.Offset;
	static createInstrumentsVector(
		builder: flatbuffers.Builder,
		data: number[] | Uint32Array | Uint8Array,
	): flatbuffers.Offset {
		builder.startVector(4, data.length, 4);
		for (let i = data.length - 1; i >= 0; i--) {
			builder.addInt32(data[i]!);
		}
		return builder.endVector();
	}

	static startInstrumentsVector(
		builder: flatbuffers.Builder,
		numElems: number,
	) {
		builder.startVector(4, numElems, 4);
	}

	static addBookDepth(builder: flatbuffers.Builder, bookDepth: number) {
		builder.addFieldInt16(1, bookDepth, 0);
	}

	static addTrades(builder: flatbuffers.Builder, trades: boolean) {
		builder.addFieldInt8(2, +trades, +false);
	}

	static addPositions(builder: flatbuffers.Builder, positions: boolean) {
		builder.addFieldInt8(3, +positions, +false);
	}

	static addTeamId(builder: flatbuffers.Builder, teamId: number) {
		builder.addFieldInt32(4, teamId, 0);
	}

	static endSubscribe(builder: flatbuffers.Builder): flatbuffers.Offset {
		const offset = builder.endObject();
		return offset;
	}

	static createSubscribe(
		builder: flatbuffers.Builder,
		instrumentsOffset: flatbuffers.Offset,
		bookDepth: number,
		trades: boolean,
		positions: boolean,
		teamId: number,
	): flatbuffers.Offset {
		Subscribe.startSubscribe(builder);
		Subscribe.addInstruments(builder, instrumentsOffset);
		Subscribe.addBookDepth(builder, bookDepth);
		Subscribe.addTrades(builder, trades);
		Subscribe.addPositions(builder, positions);
		Subscribe.addTeamId(builder, teamId);
		return Subscribe.endSubscribe(builder);
	}

	unpack(): SubscribeT {
		return new SubscribeT(
			this.bb!.createScalarList<number>(
				this.instruments.bind(this),
				this.instrumentsLength(),
			),
			this.bookDepth(),
			this.trades(),
			this.positions(),
			this.teamId(),
		);
	}

	unpackTo(_o: SubscribeT): void {
		_o.instruments = this.bb!.createScalarList<number>(
			this.instruments.bind(this),
			this.instrumentsLength(),
		);
		_o.bookDepth = this.bookDepth();
		_o.trades = this.trades();
		_o.positions = this.positions();
		_o.teamId = this.teamId();
	}
}

export class SubscribeT implements flatbuffers.IGeneratedObject {
	constructor(
		public instruments: number[] = [],
		public bookDepth: number = 0,
		public trades: boolean = false,
		public positions: boolean = false,
		public teamId: number = 0,
	) {}

	pack(builder: flatbuffers.Builder): flatbuffers.Offset {
		const instruments = Subscribe.createInstrumentsVector(
			builder,
			this.instruments,
		);

		return Subscribe.createSubscribe(
			builder,
			instruments,
			this.bookDepth,
			this.trades,
			this.positions,
			this.teamId,
		);
	}
}
