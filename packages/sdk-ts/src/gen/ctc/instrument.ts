// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from "flatbuffers";

import { InstrType } from "../ctc/instr-type.js";

export class Instrument implements flatbuffers.IUnpackableObject<InstrumentT> {
	bb: flatbuffers.ByteBuffer | null = null;
	bb_pos = 0;
	__init(i: number, bb: flatbuffers.ByteBuffer): Instrument {
		this.bb_pos = i;
		this.bb = bb;
		return this;
	}

	static getRootAsInstrument(
		bb: flatbuffers.ByteBuffer,
		obj?: Instrument,
	): Instrument {
		return (obj || new Instrument()).__init(
			bb.readInt32(bb.position()) + bb.position(),
			bb,
		);
	}

	static getSizePrefixedRootAsInstrument(
		bb: flatbuffers.ByteBuffer,
		obj?: Instrument,
	): Instrument {
		bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
		return (obj || new Instrument()).__init(
			bb.readInt32(bb.position()) + bb.position(),
			bb,
		);
	}

	id(): number {
		const offset = this.bb!.__offset(this.bb_pos, 4);
		return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
	}

	symbol(): string | null;
	symbol(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;
	symbol(optionalEncoding?: any): string | Uint8Array | null {
		const offset = this.bb!.__offset(this.bb_pos, 6);
		return offset
			? this.bb!.__string(this.bb_pos + offset, optionalEncoding)
			: null;
	}

	type(): InstrType {
		const offset = this.bb!.__offset(this.bb_pos, 8);
		return offset ? this.bb!.readUint8(this.bb_pos + offset) : InstrType.Equity;
	}

	currency(): string | null;
	currency(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;
	currency(optionalEncoding?: any): string | Uint8Array | null {
		const offset = this.bb!.__offset(this.bb_pos, 10);
		return offset
			? this.bb!.__string(this.bb_pos + offset, optionalEncoding)
			: null;
	}

	tickSizeNanos(): number {
		const offset = this.bb!.__offset(this.bb_pos, 12);
		return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
	}

	tickSizeTicks(): number {
		const offset = this.bb!.__offset(this.bb_pos, 14);
		return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
	}

	lotSizeLots(): number {
		const offset = this.bb!.__offset(this.bb_pos, 16);
		return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
	}

	meta(): bigint {
		const offset = this.bb!.__offset(this.bb_pos, 18);
		return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt("0");
	}

	static startInstrument(builder: flatbuffers.Builder) {
		builder.startObject(8);
	}

	static addId(builder: flatbuffers.Builder, id: number) {
		builder.addFieldInt32(0, id, 0);
	}

	static addSymbol(
		builder: flatbuffers.Builder,
		symbolOffset: flatbuffers.Offset,
	) {
		builder.addFieldOffset(1, symbolOffset, 0);
	}

	static addType(builder: flatbuffers.Builder, type: InstrType) {
		builder.addFieldInt8(2, type, InstrType.Equity);
	}

	static addCurrency(
		builder: flatbuffers.Builder,
		currencyOffset: flatbuffers.Offset,
	) {
		builder.addFieldOffset(3, currencyOffset, 0);
	}

	static addTickSizeNanos(builder: flatbuffers.Builder, tickSizeNanos: number) {
		builder.addFieldInt32(4, tickSizeNanos, 0);
	}

	static addTickSizeTicks(builder: flatbuffers.Builder, tickSizeTicks: number) {
		builder.addFieldInt32(5, tickSizeTicks, 0);
	}

	static addLotSizeLots(builder: flatbuffers.Builder, lotSizeLots: number) {
		builder.addFieldInt32(6, lotSizeLots, 0);
	}

	static addMeta(builder: flatbuffers.Builder, meta: bigint) {
		builder.addFieldInt64(7, meta, BigInt("0"));
	}

	static endInstrument(builder: flatbuffers.Builder): flatbuffers.Offset {
		const offset = builder.endObject();
		return offset;
	}

	static createInstrument(
		builder: flatbuffers.Builder,
		id: number,
		symbolOffset: flatbuffers.Offset,
		type: InstrType,
		currencyOffset: flatbuffers.Offset,
		tickSizeNanos: number,
		tickSizeTicks: number,
		lotSizeLots: number,
		meta: bigint,
	): flatbuffers.Offset {
		Instrument.startInstrument(builder);
		Instrument.addId(builder, id);
		Instrument.addSymbol(builder, symbolOffset);
		Instrument.addType(builder, type);
		Instrument.addCurrency(builder, currencyOffset);
		Instrument.addTickSizeNanos(builder, tickSizeNanos);
		Instrument.addTickSizeTicks(builder, tickSizeTicks);
		Instrument.addLotSizeLots(builder, lotSizeLots);
		Instrument.addMeta(builder, meta);
		return Instrument.endInstrument(builder);
	}

	unpack(): InstrumentT {
		return new InstrumentT(
			this.id(),
			this.symbol(),
			this.type(),
			this.currency(),
			this.tickSizeNanos(),
			this.tickSizeTicks(),
			this.lotSizeLots(),
			this.meta(),
		);
	}

	unpackTo(_o: InstrumentT): void {
		_o.id = this.id();
		_o.symbol = this.symbol();
		_o.type = this.type();
		_o.currency = this.currency();
		_o.tickSizeNanos = this.tickSizeNanos();
		_o.tickSizeTicks = this.tickSizeTicks();
		_o.lotSizeLots = this.lotSizeLots();
		_o.meta = this.meta();
	}
}

export class InstrumentT implements flatbuffers.IGeneratedObject {
	constructor(
		public id: number = 0,
		public symbol: string | Uint8Array | null = null,
		public type: InstrType = InstrType.Equity,
		public currency: string | Uint8Array | null = null,
		public tickSizeNanos: number = 0,
		public tickSizeTicks: number = 0,
		public lotSizeLots: number = 0,
		public meta: bigint = BigInt("0"),
	) {}

	pack(builder: flatbuffers.Builder): flatbuffers.Offset {
		const symbol =
			this.symbol !== null ? builder.createString(this.symbol!) : 0;
		const currency =
			this.currency !== null ? builder.createString(this.currency!) : 0;

		return Instrument.createInstrument(
			builder,
			this.id,
			symbol,
			this.type,
			currency,
			this.tickSizeNanos,
			this.tickSizeTicks,
			this.lotSizeLots,
			this.meta,
		);
	}
}
