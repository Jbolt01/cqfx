// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from "flatbuffers";

export class Unsubscribe
	implements flatbuffers.IUnpackableObject<UnsubscribeT>
{
	bb: flatbuffers.ByteBuffer | null = null;
	bb_pos = 0;
	__init(i: number, bb: flatbuffers.ByteBuffer): Unsubscribe {
		this.bb_pos = i;
		this.bb = bb;
		return this;
	}

	static getRootAsUnsubscribe(
		bb: flatbuffers.ByteBuffer,
		obj?: Unsubscribe,
	): Unsubscribe {
		return (obj || new Unsubscribe()).__init(
			bb.readInt32(bb.position()) + bb.position(),
			bb,
		);
	}

	static getSizePrefixedRootAsUnsubscribe(
		bb: flatbuffers.ByteBuffer,
		obj?: Unsubscribe,
	): Unsubscribe {
		bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
		return (obj || new Unsubscribe()).__init(
			bb.readInt32(bb.position()) + bb.position(),
			bb,
		);
	}

	instruments(index: number): number | null {
		const offset = this.bb!.__offset(this.bb_pos, 4);
		return offset
			? this.bb!.readUint32(this.bb!.__vector(this.bb_pos + offset) + index * 4)
			: 0;
	}

	instrumentsLength(): number {
		const offset = this.bb!.__offset(this.bb_pos, 4);
		return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
	}

	instrumentsArray(): Uint32Array | null {
		const offset = this.bb!.__offset(this.bb_pos, 4);
		return offset
			? new Uint32Array(
					this.bb!.bytes().buffer,
					this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
					this.bb!.__vector_len(this.bb_pos + offset),
				)
			: null;
	}

	teamId(): number {
		const offset = this.bb!.__offset(this.bb_pos, 6);
		return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
	}

	static startUnsubscribe(builder: flatbuffers.Builder) {
		builder.startObject(2);
	}

	static addInstruments(
		builder: flatbuffers.Builder,
		instrumentsOffset: flatbuffers.Offset,
	) {
		builder.addFieldOffset(0, instrumentsOffset, 0);
	}

	static createInstrumentsVector(
		builder: flatbuffers.Builder,
		data: number[] | Uint32Array,
	): flatbuffers.Offset;
	/**
	 * @deprecated This Uint8Array overload will be removed in the future.
	 */
	static createInstrumentsVector(
		builder: flatbuffers.Builder,
		data: number[] | Uint8Array,
	): flatbuffers.Offset;
	static createInstrumentsVector(
		builder: flatbuffers.Builder,
		data: number[] | Uint32Array | Uint8Array,
	): flatbuffers.Offset {
		builder.startVector(4, data.length, 4);
		for (let i = data.length - 1; i >= 0; i--) {
			builder.addInt32(data[i]!);
		}
		return builder.endVector();
	}

	static startInstrumentsVector(
		builder: flatbuffers.Builder,
		numElems: number,
	) {
		builder.startVector(4, numElems, 4);
	}

	static addTeamId(builder: flatbuffers.Builder, teamId: number) {
		builder.addFieldInt32(1, teamId, 0);
	}

	static endUnsubscribe(builder: flatbuffers.Builder): flatbuffers.Offset {
		const offset = builder.endObject();
		return offset;
	}

	static createUnsubscribe(
		builder: flatbuffers.Builder,
		instrumentsOffset: flatbuffers.Offset,
		teamId: number,
	): flatbuffers.Offset {
		Unsubscribe.startUnsubscribe(builder);
		Unsubscribe.addInstruments(builder, instrumentsOffset);
		Unsubscribe.addTeamId(builder, teamId);
		return Unsubscribe.endUnsubscribe(builder);
	}

	unpack(): UnsubscribeT {
		return new UnsubscribeT(
			this.bb!.createScalarList<number>(
				this.instruments.bind(this),
				this.instrumentsLength(),
			),
			this.teamId(),
		);
	}

	unpackTo(_o: UnsubscribeT): void {
		_o.instruments = this.bb!.createScalarList<number>(
			this.instruments.bind(this),
			this.instrumentsLength(),
		);
		_o.teamId = this.teamId();
	}
}

export class UnsubscribeT implements flatbuffers.IGeneratedObject {
	constructor(
		public instruments: number[] = [],
		public teamId: number = 0,
	) {}

	pack(builder: flatbuffers.Builder): flatbuffers.Offset {
		const instruments = Unsubscribe.createInstrumentsVector(
			builder,
			this.instruments,
		);

		return Unsubscribe.createUnsubscribe(builder, instruments, this.teamId);
	}
}
