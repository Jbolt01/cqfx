// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ENVELOPE_CTC_H_
#define FLATBUFFERS_GENERATED_ENVELOPE_CTC_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace ctc {

struct PriceLevelDelta;
struct PriceLevelDeltaBuilder;

struct BookDelta;
struct BookDeltaBuilder;

struct Trade;
struct TradeBuilder;

struct PositionUpdate;
struct PositionUpdateBuilder;

struct RiskLimit;
struct RiskLimitBuilder;

struct SessionEvent;
struct SessionEventBuilder;

struct Instrument;
struct InstrumentBuilder;

struct EtfComponent;
struct EtfComponentBuilder;

struct OptionMeta;
struct OptionMetaBuilder;

struct ConfigSnapshot;
struct ConfigSnapshotBuilder;

struct OrderNew;
struct OrderNewBuilder;

struct OrderReplace;
struct OrderReplaceBuilder;

struct OrderCancel;
struct OrderCancelBuilder;

struct CancelAll;
struct CancelAllBuilder;

struct Ack;
struct AckBuilder;

struct ETFCreateRedeem;
struct ETFCreateRedeemBuilder;

struct EtfLeg;
struct EtfLegBuilder;

struct ETFCreateRedeemResult;
struct ETFCreateRedeemResultBuilder;

struct Subscribe;
struct SubscribeBuilder;

struct Unsubscribe;
struct UnsubscribeBuilder;

struct Heartbeat;
struct HeartbeatBuilder;

struct Auth;
struct AuthBuilder;

struct Message;
struct MessageBuilder;

enum Side : uint8_t {
  Side_Buy = 0,
  Side_Sell = 1,
  Side_MIN = Side_Buy,
  Side_MAX = Side_Sell
};

inline const Side (&EnumValuesSide())[2] {
  static const Side values[] = {
    Side_Buy,
    Side_Sell
  };
  return values;
}

inline const char * const *EnumNamesSide() {
  static const char * const names[3] = {
    "Buy",
    "Sell",
    nullptr
  };
  return names;
}

inline const char *EnumNameSide(Side e) {
  if (::flatbuffers::IsOutRange(e, Side_Buy, Side_Sell)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSide()[index];
}

enum OrderType : uint8_t {
  OrderType_Limit = 0,
  OrderType_Market = 1,
  OrderType_MIN = OrderType_Limit,
  OrderType_MAX = OrderType_Market
};

inline const OrderType (&EnumValuesOrderType())[2] {
  static const OrderType values[] = {
    OrderType_Limit,
    OrderType_Market
  };
  return values;
}

inline const char * const *EnumNamesOrderType() {
  static const char * const names[3] = {
    "Limit",
    "Market",
    nullptr
  };
  return names;
}

inline const char *EnumNameOrderType(OrderType e) {
  if (::flatbuffers::IsOutRange(e, OrderType_Limit, OrderType_Market)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOrderType()[index];
}

enum TIF : uint8_t {
  TIF_GFD = 0,
  TIF_IOC = 1,
  TIF_FOK = 2,
  TIF_MIN = TIF_GFD,
  TIF_MAX = TIF_FOK
};

inline const TIF (&EnumValuesTIF())[3] {
  static const TIF values[] = {
    TIF_GFD,
    TIF_IOC,
    TIF_FOK
  };
  return values;
}

inline const char * const *EnumNamesTIF() {
  static const char * const names[4] = {
    "GFD",
    "IOC",
    "FOK",
    nullptr
  };
  return names;
}

inline const char *EnumNameTIF(TIF e) {
  if (::flatbuffers::IsOutRange(e, TIF_GFD, TIF_FOK)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTIF()[index];
}

enum StpMode : uint8_t {
  StpMode_None = 0,
  StpMode_CancelResting = 1,
  StpMode_CancelTaker = 2,
  StpMode_DecrementBoth = 3,
  StpMode_MIN = StpMode_None,
  StpMode_MAX = StpMode_DecrementBoth
};

inline const StpMode (&EnumValuesStpMode())[4] {
  static const StpMode values[] = {
    StpMode_None,
    StpMode_CancelResting,
    StpMode_CancelTaker,
    StpMode_DecrementBoth
  };
  return values;
}

inline const char * const *EnumNamesStpMode() {
  static const char * const names[5] = {
    "None",
    "CancelResting",
    "CancelTaker",
    "DecrementBoth",
    nullptr
  };
  return names;
}

inline const char *EnumNameStpMode(StpMode e) {
  if (::flatbuffers::IsOutRange(e, StpMode_None, StpMode_DecrementBoth)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStpMode()[index];
}

enum RejectCode : uint16_t {
  RejectCode_None = 0,
  RejectCode_SessionClosed = 1,
  RejectCode_BadSymbol = 2,
  RejectCode_BadPrice = 3,
  RejectCode_BadQty = 4,
  RejectCode_PositionLimit = 5,
  RejectCode_NotionalLimit = 6,
  RejectCode_RateLimited = 7,
  RejectCode_DuplicateClOrdId = 8,
  RejectCode_UnknownOrder = 9,
  RejectCode_ReplaceConstraints = 10,
  RejectCode_CancelConstraints = 11,
  RejectCode_RiskUnavailable = 12,
  RejectCode_Unauthorized = 13,
  RejectCode_MIN = RejectCode_None,
  RejectCode_MAX = RejectCode_Unauthorized
};

inline const RejectCode (&EnumValuesRejectCode())[14] {
  static const RejectCode values[] = {
    RejectCode_None,
    RejectCode_SessionClosed,
    RejectCode_BadSymbol,
    RejectCode_BadPrice,
    RejectCode_BadQty,
    RejectCode_PositionLimit,
    RejectCode_NotionalLimit,
    RejectCode_RateLimited,
    RejectCode_DuplicateClOrdId,
    RejectCode_UnknownOrder,
    RejectCode_ReplaceConstraints,
    RejectCode_CancelConstraints,
    RejectCode_RiskUnavailable,
    RejectCode_Unauthorized
  };
  return values;
}

inline const char * const *EnumNamesRejectCode() {
  static const char * const names[15] = {
    "None",
    "SessionClosed",
    "BadSymbol",
    "BadPrice",
    "BadQty",
    "PositionLimit",
    "NotionalLimit",
    "RateLimited",
    "DuplicateClOrdId",
    "UnknownOrder",
    "ReplaceConstraints",
    "CancelConstraints",
    "RiskUnavailable",
    "Unauthorized",
    nullptr
  };
  return names;
}

inline const char *EnumNameRejectCode(RejectCode e) {
  if (::flatbuffers::IsOutRange(e, RejectCode_None, RejectCode_Unauthorized)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRejectCode()[index];
}

enum ExecType : uint8_t {
  ExecType_Ack = 0,
  ExecType_PartialFill = 1,
  ExecType_Fill = 2,
  ExecType_CancelAck = 3,
  ExecType_ReplaceAck = 4,
  ExecType_Reject = 5,
  ExecType_MIN = ExecType_Ack,
  ExecType_MAX = ExecType_Reject
};

inline const ExecType (&EnumValuesExecType())[6] {
  static const ExecType values[] = {
    ExecType_Ack,
    ExecType_PartialFill,
    ExecType_Fill,
    ExecType_CancelAck,
    ExecType_ReplaceAck,
    ExecType_Reject
  };
  return values;
}

inline const char * const *EnumNamesExecType() {
  static const char * const names[7] = {
    "Ack",
    "PartialFill",
    "Fill",
    "CancelAck",
    "ReplaceAck",
    "Reject",
    nullptr
  };
  return names;
}

inline const char *EnumNameExecType(ExecType e) {
  if (::flatbuffers::IsOutRange(e, ExecType_Ack, ExecType_Reject)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExecType()[index];
}

enum EventType : uint8_t {
  EventType_Heartbeat = 0,
  EventType_Session = 1,
  EventType_Config = 2,
  EventType_MIN = EventType_Heartbeat,
  EventType_MAX = EventType_Config
};

inline const EventType (&EnumValuesEventType())[3] {
  static const EventType values[] = {
    EventType_Heartbeat,
    EventType_Session,
    EventType_Config
  };
  return values;
}

inline const char * const *EnumNamesEventType() {
  static const char * const names[4] = {
    "Heartbeat",
    "Session",
    "Config",
    nullptr
  };
  return names;
}

inline const char *EnumNameEventType(EventType e) {
  if (::flatbuffers::IsOutRange(e, EventType_Heartbeat, EventType_Config)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEventType()[index];
}

enum InstrType : uint8_t {
  InstrType_Equity = 0,
  InstrType_ETF = 1,
  InstrType_Option = 2,
  InstrType_MIN = InstrType_Equity,
  InstrType_MAX = InstrType_Option
};

inline const InstrType (&EnumValuesInstrType())[3] {
  static const InstrType values[] = {
    InstrType_Equity,
    InstrType_ETF,
    InstrType_Option
  };
  return values;
}

inline const char * const *EnumNamesInstrType() {
  static const char * const names[4] = {
    "Equity",
    "ETF",
    "Option",
    nullptr
  };
  return names;
}

inline const char *EnumNameInstrType(InstrType e) {
  if (::flatbuffers::IsOutRange(e, InstrType_Equity, InstrType_Option)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInstrType()[index];
}

enum DeltaKind : uint8_t {
  DeltaKind_PriceLevel = 0,
  DeltaKind_Snapshot = 1,
  DeltaKind_MIN = DeltaKind_PriceLevel,
  DeltaKind_MAX = DeltaKind_Snapshot
};

inline const DeltaKind (&EnumValuesDeltaKind())[2] {
  static const DeltaKind values[] = {
    DeltaKind_PriceLevel,
    DeltaKind_Snapshot
  };
  return values;
}

inline const char * const *EnumNamesDeltaKind() {
  static const char * const names[3] = {
    "PriceLevel",
    "Snapshot",
    nullptr
  };
  return names;
}

inline const char *EnumNameDeltaKind(DeltaKind e) {
  if (::flatbuffers::IsOutRange(e, DeltaKind_PriceLevel, DeltaKind_Snapshot)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDeltaKind()[index];
}

enum Payload : uint8_t {
  Payload_NONE = 0,
  Payload_Auth = 1,
  Payload_Subscribe = 2,
  Payload_Unsubscribe = 3,
  Payload_Heartbeat = 4,
  Payload_OrderNew = 5,
  Payload_OrderReplace = 6,
  Payload_OrderCancel = 7,
  Payload_CancelAll = 8,
  Payload_ETFCreateRedeem = 9,
  Payload_Ack = 10,
  Payload_Trade = 11,
  Payload_BookDelta = 12,
  Payload_PositionUpdate = 13,
  Payload_ConfigSnapshot = 14,
  Payload_SessionEvent = 15,
  Payload_ETFCreateRedeemResult = 16,
  Payload_MIN = Payload_NONE,
  Payload_MAX = Payload_ETFCreateRedeemResult
};

inline const Payload (&EnumValuesPayload())[17] {
  static const Payload values[] = {
    Payload_NONE,
    Payload_Auth,
    Payload_Subscribe,
    Payload_Unsubscribe,
    Payload_Heartbeat,
    Payload_OrderNew,
    Payload_OrderReplace,
    Payload_OrderCancel,
    Payload_CancelAll,
    Payload_ETFCreateRedeem,
    Payload_Ack,
    Payload_Trade,
    Payload_BookDelta,
    Payload_PositionUpdate,
    Payload_ConfigSnapshot,
    Payload_SessionEvent,
    Payload_ETFCreateRedeemResult
  };
  return values;
}

inline const char * const *EnumNamesPayload() {
  static const char * const names[18] = {
    "NONE",
    "Auth",
    "Subscribe",
    "Unsubscribe",
    "Heartbeat",
    "OrderNew",
    "OrderReplace",
    "OrderCancel",
    "CancelAll",
    "ETFCreateRedeem",
    "Ack",
    "Trade",
    "BookDelta",
    "PositionUpdate",
    "ConfigSnapshot",
    "SessionEvent",
    "ETFCreateRedeemResult",
    nullptr
  };
  return names;
}

inline const char *EnumNamePayload(Payload e) {
  if (::flatbuffers::IsOutRange(e, Payload_NONE, Payload_ETFCreateRedeemResult)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPayload()[index];
}

template<typename T> struct PayloadTraits {
  static const Payload enum_value = Payload_NONE;
};

template<> struct PayloadTraits<ctc::Auth> {
  static const Payload enum_value = Payload_Auth;
};

template<> struct PayloadTraits<ctc::Subscribe> {
  static const Payload enum_value = Payload_Subscribe;
};

template<> struct PayloadTraits<ctc::Unsubscribe> {
  static const Payload enum_value = Payload_Unsubscribe;
};

template<> struct PayloadTraits<ctc::Heartbeat> {
  static const Payload enum_value = Payload_Heartbeat;
};

template<> struct PayloadTraits<ctc::OrderNew> {
  static const Payload enum_value = Payload_OrderNew;
};

template<> struct PayloadTraits<ctc::OrderReplace> {
  static const Payload enum_value = Payload_OrderReplace;
};

template<> struct PayloadTraits<ctc::OrderCancel> {
  static const Payload enum_value = Payload_OrderCancel;
};

template<> struct PayloadTraits<ctc::CancelAll> {
  static const Payload enum_value = Payload_CancelAll;
};

template<> struct PayloadTraits<ctc::ETFCreateRedeem> {
  static const Payload enum_value = Payload_ETFCreateRedeem;
};

template<> struct PayloadTraits<ctc::Ack> {
  static const Payload enum_value = Payload_Ack;
};

template<> struct PayloadTraits<ctc::Trade> {
  static const Payload enum_value = Payload_Trade;
};

template<> struct PayloadTraits<ctc::BookDelta> {
  static const Payload enum_value = Payload_BookDelta;
};

template<> struct PayloadTraits<ctc::PositionUpdate> {
  static const Payload enum_value = Payload_PositionUpdate;
};

template<> struct PayloadTraits<ctc::ConfigSnapshot> {
  static const Payload enum_value = Payload_ConfigSnapshot;
};

template<> struct PayloadTraits<ctc::SessionEvent> {
  static const Payload enum_value = Payload_SessionEvent;
};

template<> struct PayloadTraits<ctc::ETFCreateRedeemResult> {
  static const Payload enum_value = Payload_ETFCreateRedeemResult;
};

bool VerifyPayload(::flatbuffers::Verifier &verifier, const void *obj, Payload type);
bool VerifyPayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct PriceLevelDelta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PriceLevelDeltaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIDE = 4,
    VT_PXTICKS = 6,
    VT_DELTALOTS = 8
  };
  ctc::Side side() const {
    return static_cast<ctc::Side>(GetField<uint8_t>(VT_SIDE, 0));
  }
  int32_t pxTicks() const {
    return GetField<int32_t>(VT_PXTICKS, 0);
  }
  int64_t deltaLots() const {
    return GetField<int64_t>(VT_DELTALOTS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SIDE, 1) &&
           VerifyField<int32_t>(verifier, VT_PXTICKS, 4) &&
           VerifyField<int64_t>(verifier, VT_DELTALOTS, 8) &&
           verifier.EndTable();
  }
};

struct PriceLevelDeltaBuilder {
  typedef PriceLevelDelta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_side(ctc::Side side) {
    fbb_.AddElement<uint8_t>(PriceLevelDelta::VT_SIDE, static_cast<uint8_t>(side), 0);
  }
  void add_pxTicks(int32_t pxTicks) {
    fbb_.AddElement<int32_t>(PriceLevelDelta::VT_PXTICKS, pxTicks, 0);
  }
  void add_deltaLots(int64_t deltaLots) {
    fbb_.AddElement<int64_t>(PriceLevelDelta::VT_DELTALOTS, deltaLots, 0);
  }
  explicit PriceLevelDeltaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PriceLevelDelta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PriceLevelDelta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PriceLevelDelta> CreatePriceLevelDelta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ctc::Side side = ctc::Side_Buy,
    int32_t pxTicks = 0,
    int64_t deltaLots = 0) {
  PriceLevelDeltaBuilder builder_(_fbb);
  builder_.add_deltaLots(deltaLots);
  builder_.add_pxTicks(pxTicks);
  builder_.add_side(side);
  return builder_.Finish();
}

struct BookDelta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BookDeltaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTRUMENTID = 4,
    VT_FEEDSEQ = 6,
    VT_KIND = 8,
    VT_LEVELS = 10,
    VT_TSNANOS = 12,
    VT_BESTBIDTICKS = 14,
    VT_BESTASKTICKS = 16
  };
  uint32_t instrumentId() const {
    return GetField<uint32_t>(VT_INSTRUMENTID, 0);
  }
  uint64_t feedSeq() const {
    return GetField<uint64_t>(VT_FEEDSEQ, 0);
  }
  ctc::DeltaKind kind() const {
    return static_cast<ctc::DeltaKind>(GetField<uint8_t>(VT_KIND, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ctc::PriceLevelDelta>> *levels() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ctc::PriceLevelDelta>> *>(VT_LEVELS);
  }
  uint64_t tsNanos() const {
    return GetField<uint64_t>(VT_TSNANOS, 0);
  }
  int32_t bestBidTicks() const {
    return GetField<int32_t>(VT_BESTBIDTICKS, 0);
  }
  int32_t bestAskTicks() const {
    return GetField<int32_t>(VT_BESTASKTICKS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_INSTRUMENTID, 4) &&
           VerifyField<uint64_t>(verifier, VT_FEEDSEQ, 8) &&
           VerifyField<uint8_t>(verifier, VT_KIND, 1) &&
           VerifyOffset(verifier, VT_LEVELS) &&
           verifier.VerifyVector(levels()) &&
           verifier.VerifyVectorOfTables(levels()) &&
           VerifyField<uint64_t>(verifier, VT_TSNANOS, 8) &&
           VerifyField<int32_t>(verifier, VT_BESTBIDTICKS, 4) &&
           VerifyField<int32_t>(verifier, VT_BESTASKTICKS, 4) &&
           verifier.EndTable();
  }
};

struct BookDeltaBuilder {
  typedef BookDelta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_instrumentId(uint32_t instrumentId) {
    fbb_.AddElement<uint32_t>(BookDelta::VT_INSTRUMENTID, instrumentId, 0);
  }
  void add_feedSeq(uint64_t feedSeq) {
    fbb_.AddElement<uint64_t>(BookDelta::VT_FEEDSEQ, feedSeq, 0);
  }
  void add_kind(ctc::DeltaKind kind) {
    fbb_.AddElement<uint8_t>(BookDelta::VT_KIND, static_cast<uint8_t>(kind), 0);
  }
  void add_levels(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ctc::PriceLevelDelta>>> levels) {
    fbb_.AddOffset(BookDelta::VT_LEVELS, levels);
  }
  void add_tsNanos(uint64_t tsNanos) {
    fbb_.AddElement<uint64_t>(BookDelta::VT_TSNANOS, tsNanos, 0);
  }
  void add_bestBidTicks(int32_t bestBidTicks) {
    fbb_.AddElement<int32_t>(BookDelta::VT_BESTBIDTICKS, bestBidTicks, 0);
  }
  void add_bestAskTicks(int32_t bestAskTicks) {
    fbb_.AddElement<int32_t>(BookDelta::VT_BESTASKTICKS, bestAskTicks, 0);
  }
  explicit BookDeltaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BookDelta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BookDelta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BookDelta> CreateBookDelta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t instrumentId = 0,
    uint64_t feedSeq = 0,
    ctc::DeltaKind kind = ctc::DeltaKind_PriceLevel,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ctc::PriceLevelDelta>>> levels = 0,
    uint64_t tsNanos = 0,
    int32_t bestBidTicks = 0,
    int32_t bestAskTicks = 0) {
  BookDeltaBuilder builder_(_fbb);
  builder_.add_tsNanos(tsNanos);
  builder_.add_feedSeq(feedSeq);
  builder_.add_bestAskTicks(bestAskTicks);
  builder_.add_bestBidTicks(bestBidTicks);
  builder_.add_levels(levels);
  builder_.add_instrumentId(instrumentId);
  builder_.add_kind(kind);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BookDelta> CreateBookDeltaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t instrumentId = 0,
    uint64_t feedSeq = 0,
    ctc::DeltaKind kind = ctc::DeltaKind_PriceLevel,
    const std::vector<::flatbuffers::Offset<ctc::PriceLevelDelta>> *levels = nullptr,
    uint64_t tsNanos = 0,
    int32_t bestBidTicks = 0,
    int32_t bestAskTicks = 0) {
  auto levels__ = levels ? _fbb.CreateVector<::flatbuffers::Offset<ctc::PriceLevelDelta>>(*levels) : 0;
  return ctc::CreateBookDelta(
      _fbb,
      instrumentId,
      feedSeq,
      kind,
      levels__,
      tsNanos,
      bestBidTicks,
      bestAskTicks);
}

struct Trade FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TradeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTRUMENTID = 4,
    VT_TRADEID = 6,
    VT_PXTICKS = 8,
    VT_LOTS = 10,
    VT_AGGRESSOR = 12,
    VT_TSNANOS = 14,
    VT_MATCHID = 16
  };
  uint32_t instrumentId() const {
    return GetField<uint32_t>(VT_INSTRUMENTID, 0);
  }
  uint64_t tradeId() const {
    return GetField<uint64_t>(VT_TRADEID, 0);
  }
  int32_t pxTicks() const {
    return GetField<int32_t>(VT_PXTICKS, 0);
  }
  int64_t lots() const {
    return GetField<int64_t>(VT_LOTS, 0);
  }
  ctc::Side aggressor() const {
    return static_cast<ctc::Side>(GetField<uint8_t>(VT_AGGRESSOR, 0));
  }
  uint64_t tsNanos() const {
    return GetField<uint64_t>(VT_TSNANOS, 0);
  }
  uint64_t matchId() const {
    return GetField<uint64_t>(VT_MATCHID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_INSTRUMENTID, 4) &&
           VerifyField<uint64_t>(verifier, VT_TRADEID, 8) &&
           VerifyField<int32_t>(verifier, VT_PXTICKS, 4) &&
           VerifyField<int64_t>(verifier, VT_LOTS, 8) &&
           VerifyField<uint8_t>(verifier, VT_AGGRESSOR, 1) &&
           VerifyField<uint64_t>(verifier, VT_TSNANOS, 8) &&
           VerifyField<uint64_t>(verifier, VT_MATCHID, 8) &&
           verifier.EndTable();
  }
};

struct TradeBuilder {
  typedef Trade Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_instrumentId(uint32_t instrumentId) {
    fbb_.AddElement<uint32_t>(Trade::VT_INSTRUMENTID, instrumentId, 0);
  }
  void add_tradeId(uint64_t tradeId) {
    fbb_.AddElement<uint64_t>(Trade::VT_TRADEID, tradeId, 0);
  }
  void add_pxTicks(int32_t pxTicks) {
    fbb_.AddElement<int32_t>(Trade::VT_PXTICKS, pxTicks, 0);
  }
  void add_lots(int64_t lots) {
    fbb_.AddElement<int64_t>(Trade::VT_LOTS, lots, 0);
  }
  void add_aggressor(ctc::Side aggressor) {
    fbb_.AddElement<uint8_t>(Trade::VT_AGGRESSOR, static_cast<uint8_t>(aggressor), 0);
  }
  void add_tsNanos(uint64_t tsNanos) {
    fbb_.AddElement<uint64_t>(Trade::VT_TSNANOS, tsNanos, 0);
  }
  void add_matchId(uint64_t matchId) {
    fbb_.AddElement<uint64_t>(Trade::VT_MATCHID, matchId, 0);
  }
  explicit TradeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Trade> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Trade>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Trade> CreateTrade(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t instrumentId = 0,
    uint64_t tradeId = 0,
    int32_t pxTicks = 0,
    int64_t lots = 0,
    ctc::Side aggressor = ctc::Side_Buy,
    uint64_t tsNanos = 0,
    uint64_t matchId = 0) {
  TradeBuilder builder_(_fbb);
  builder_.add_matchId(matchId);
  builder_.add_tsNanos(tsNanos);
  builder_.add_lots(lots);
  builder_.add_tradeId(tradeId);
  builder_.add_pxTicks(pxTicks);
  builder_.add_instrumentId(instrumentId);
  builder_.add_aggressor(aggressor);
  return builder_.Finish();
}

struct PositionUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PositionUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEAMID = 4,
    VT_INSTRUMENTID = 6,
    VT_POSLOTS = 8,
    VT_OPENBUYLOTS = 10,
    VT_OPENSELLLOTS = 12,
    VT_REALIZEDPNLTICKS = 14,
    VT_UNREALIZEDPNLTICKS = 16,
    VT_HEADROOMLONGLOTS = 18,
    VT_HEADROOMSHORTLOTS = 20,
    VT_TSNANOS = 22
  };
  uint32_t teamId() const {
    return GetField<uint32_t>(VT_TEAMID, 0);
  }
  uint32_t instrumentId() const {
    return GetField<uint32_t>(VT_INSTRUMENTID, 0);
  }
  int64_t posLots() const {
    return GetField<int64_t>(VT_POSLOTS, 0);
  }
  int64_t openBuyLots() const {
    return GetField<int64_t>(VT_OPENBUYLOTS, 0);
  }
  int64_t openSellLots() const {
    return GetField<int64_t>(VT_OPENSELLLOTS, 0);
  }
  int64_t realizedPnlTicks() const {
    return GetField<int64_t>(VT_REALIZEDPNLTICKS, 0);
  }
  int64_t unrealizedPnlTicks() const {
    return GetField<int64_t>(VT_UNREALIZEDPNLTICKS, 0);
  }
  int64_t headroomLongLots() const {
    return GetField<int64_t>(VT_HEADROOMLONGLOTS, 0);
  }
  int64_t headroomShortLots() const {
    return GetField<int64_t>(VT_HEADROOMSHORTLOTS, 0);
  }
  uint64_t tsNanos() const {
    return GetField<uint64_t>(VT_TSNANOS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TEAMID, 4) &&
           VerifyField<uint32_t>(verifier, VT_INSTRUMENTID, 4) &&
           VerifyField<int64_t>(verifier, VT_POSLOTS, 8) &&
           VerifyField<int64_t>(verifier, VT_OPENBUYLOTS, 8) &&
           VerifyField<int64_t>(verifier, VT_OPENSELLLOTS, 8) &&
           VerifyField<int64_t>(verifier, VT_REALIZEDPNLTICKS, 8) &&
           VerifyField<int64_t>(verifier, VT_UNREALIZEDPNLTICKS, 8) &&
           VerifyField<int64_t>(verifier, VT_HEADROOMLONGLOTS, 8) &&
           VerifyField<int64_t>(verifier, VT_HEADROOMSHORTLOTS, 8) &&
           VerifyField<uint64_t>(verifier, VT_TSNANOS, 8) &&
           verifier.EndTable();
  }
};

struct PositionUpdateBuilder {
  typedef PositionUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_teamId(uint32_t teamId) {
    fbb_.AddElement<uint32_t>(PositionUpdate::VT_TEAMID, teamId, 0);
  }
  void add_instrumentId(uint32_t instrumentId) {
    fbb_.AddElement<uint32_t>(PositionUpdate::VT_INSTRUMENTID, instrumentId, 0);
  }
  void add_posLots(int64_t posLots) {
    fbb_.AddElement<int64_t>(PositionUpdate::VT_POSLOTS, posLots, 0);
  }
  void add_openBuyLots(int64_t openBuyLots) {
    fbb_.AddElement<int64_t>(PositionUpdate::VT_OPENBUYLOTS, openBuyLots, 0);
  }
  void add_openSellLots(int64_t openSellLots) {
    fbb_.AddElement<int64_t>(PositionUpdate::VT_OPENSELLLOTS, openSellLots, 0);
  }
  void add_realizedPnlTicks(int64_t realizedPnlTicks) {
    fbb_.AddElement<int64_t>(PositionUpdate::VT_REALIZEDPNLTICKS, realizedPnlTicks, 0);
  }
  void add_unrealizedPnlTicks(int64_t unrealizedPnlTicks) {
    fbb_.AddElement<int64_t>(PositionUpdate::VT_UNREALIZEDPNLTICKS, unrealizedPnlTicks, 0);
  }
  void add_headroomLongLots(int64_t headroomLongLots) {
    fbb_.AddElement<int64_t>(PositionUpdate::VT_HEADROOMLONGLOTS, headroomLongLots, 0);
  }
  void add_headroomShortLots(int64_t headroomShortLots) {
    fbb_.AddElement<int64_t>(PositionUpdate::VT_HEADROOMSHORTLOTS, headroomShortLots, 0);
  }
  void add_tsNanos(uint64_t tsNanos) {
    fbb_.AddElement<uint64_t>(PositionUpdate::VT_TSNANOS, tsNanos, 0);
  }
  explicit PositionUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PositionUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PositionUpdate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PositionUpdate> CreatePositionUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t teamId = 0,
    uint32_t instrumentId = 0,
    int64_t posLots = 0,
    int64_t openBuyLots = 0,
    int64_t openSellLots = 0,
    int64_t realizedPnlTicks = 0,
    int64_t unrealizedPnlTicks = 0,
    int64_t headroomLongLots = 0,
    int64_t headroomShortLots = 0,
    uint64_t tsNanos = 0) {
  PositionUpdateBuilder builder_(_fbb);
  builder_.add_tsNanos(tsNanos);
  builder_.add_headroomShortLots(headroomShortLots);
  builder_.add_headroomLongLots(headroomLongLots);
  builder_.add_unrealizedPnlTicks(unrealizedPnlTicks);
  builder_.add_realizedPnlTicks(realizedPnlTicks);
  builder_.add_openSellLots(openSellLots);
  builder_.add_openBuyLots(openBuyLots);
  builder_.add_posLots(posLots);
  builder_.add_instrumentId(instrumentId);
  builder_.add_teamId(teamId);
  return builder_.Finish();
}

struct RiskLimit FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RiskLimitBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEAMID = 4,
    VT_INSTRUMENTID = 6,
    VT_POSMINLOTS = 8,
    VT_POSMAXLOTS = 10,
    VT_NOTIONALMAXTICKS = 12,
    VT_MAXORDERSPERSEC = 14
  };
  uint32_t teamId() const {
    return GetField<uint32_t>(VT_TEAMID, 0);
  }
  uint32_t instrumentId() const {
    return GetField<uint32_t>(VT_INSTRUMENTID, 0);
  }
  int64_t posMinLots() const {
    return GetField<int64_t>(VT_POSMINLOTS, 0);
  }
  int64_t posMaxLots() const {
    return GetField<int64_t>(VT_POSMAXLOTS, 0);
  }
  int64_t notionalMaxTicks() const {
    return GetField<int64_t>(VT_NOTIONALMAXTICKS, 0);
  }
  uint32_t maxOrdersPerSec() const {
    return GetField<uint32_t>(VT_MAXORDERSPERSEC, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TEAMID, 4) &&
           VerifyField<uint32_t>(verifier, VT_INSTRUMENTID, 4) &&
           VerifyField<int64_t>(verifier, VT_POSMINLOTS, 8) &&
           VerifyField<int64_t>(verifier, VT_POSMAXLOTS, 8) &&
           VerifyField<int64_t>(verifier, VT_NOTIONALMAXTICKS, 8) &&
           VerifyField<uint32_t>(verifier, VT_MAXORDERSPERSEC, 4) &&
           verifier.EndTable();
  }
};

struct RiskLimitBuilder {
  typedef RiskLimit Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_teamId(uint32_t teamId) {
    fbb_.AddElement<uint32_t>(RiskLimit::VT_TEAMID, teamId, 0);
  }
  void add_instrumentId(uint32_t instrumentId) {
    fbb_.AddElement<uint32_t>(RiskLimit::VT_INSTRUMENTID, instrumentId, 0);
  }
  void add_posMinLots(int64_t posMinLots) {
    fbb_.AddElement<int64_t>(RiskLimit::VT_POSMINLOTS, posMinLots, 0);
  }
  void add_posMaxLots(int64_t posMaxLots) {
    fbb_.AddElement<int64_t>(RiskLimit::VT_POSMAXLOTS, posMaxLots, 0);
  }
  void add_notionalMaxTicks(int64_t notionalMaxTicks) {
    fbb_.AddElement<int64_t>(RiskLimit::VT_NOTIONALMAXTICKS, notionalMaxTicks, 0);
  }
  void add_maxOrdersPerSec(uint32_t maxOrdersPerSec) {
    fbb_.AddElement<uint32_t>(RiskLimit::VT_MAXORDERSPERSEC, maxOrdersPerSec, 0);
  }
  explicit RiskLimitBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RiskLimit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RiskLimit>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RiskLimit> CreateRiskLimit(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t teamId = 0,
    uint32_t instrumentId = 0,
    int64_t posMinLots = 0,
    int64_t posMaxLots = 0,
    int64_t notionalMaxTicks = 0,
    uint32_t maxOrdersPerSec = 0) {
  RiskLimitBuilder builder_(_fbb);
  builder_.add_notionalMaxTicks(notionalMaxTicks);
  builder_.add_posMaxLots(posMaxLots);
  builder_.add_posMinLots(posMinLots);
  builder_.add_maxOrdersPerSec(maxOrdersPerSec);
  builder_.add_instrumentId(instrumentId);
  builder_.add_teamId(teamId);
  return builder_.Finish();
}

struct SessionEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SessionEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSIONID = 4,
    VT_ROUNDNO = 6,
    VT_DAYNO = 8,
    VT_STATE = 10,
    VT_TSNANOS = 12
  };
  uint32_t sessionId() const {
    return GetField<uint32_t>(VT_SESSIONID, 0);
  }
  uint16_t roundNo() const {
    return GetField<uint16_t>(VT_ROUNDNO, 0);
  }
  uint16_t dayNo() const {
    return GetField<uint16_t>(VT_DAYNO, 0);
  }
  const ::flatbuffers::String *state() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATE);
  }
  uint64_t tsNanos() const {
    return GetField<uint64_t>(VT_TSNANOS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SESSIONID, 4) &&
           VerifyField<uint16_t>(verifier, VT_ROUNDNO, 2) &&
           VerifyField<uint16_t>(verifier, VT_DAYNO, 2) &&
           VerifyOffset(verifier, VT_STATE) &&
           verifier.VerifyString(state()) &&
           VerifyField<uint64_t>(verifier, VT_TSNANOS, 8) &&
           verifier.EndTable();
  }
};

struct SessionEventBuilder {
  typedef SessionEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sessionId(uint32_t sessionId) {
    fbb_.AddElement<uint32_t>(SessionEvent::VT_SESSIONID, sessionId, 0);
  }
  void add_roundNo(uint16_t roundNo) {
    fbb_.AddElement<uint16_t>(SessionEvent::VT_ROUNDNO, roundNo, 0);
  }
  void add_dayNo(uint16_t dayNo) {
    fbb_.AddElement<uint16_t>(SessionEvent::VT_DAYNO, dayNo, 0);
  }
  void add_state(::flatbuffers::Offset<::flatbuffers::String> state) {
    fbb_.AddOffset(SessionEvent::VT_STATE, state);
  }
  void add_tsNanos(uint64_t tsNanos) {
    fbb_.AddElement<uint64_t>(SessionEvent::VT_TSNANOS, tsNanos, 0);
  }
  explicit SessionEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SessionEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SessionEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SessionEvent> CreateSessionEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t sessionId = 0,
    uint16_t roundNo = 0,
    uint16_t dayNo = 0,
    ::flatbuffers::Offset<::flatbuffers::String> state = 0,
    uint64_t tsNanos = 0) {
  SessionEventBuilder builder_(_fbb);
  builder_.add_tsNanos(tsNanos);
  builder_.add_state(state);
  builder_.add_sessionId(sessionId);
  builder_.add_dayNo(dayNo);
  builder_.add_roundNo(roundNo);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SessionEvent> CreateSessionEventDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t sessionId = 0,
    uint16_t roundNo = 0,
    uint16_t dayNo = 0,
    const char *state = nullptr,
    uint64_t tsNanos = 0) {
  auto state__ = state ? _fbb.CreateString(state) : 0;
  return ctc::CreateSessionEvent(
      _fbb,
      sessionId,
      roundNo,
      dayNo,
      state__,
      tsNanos);
}

struct Instrument FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InstrumentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_SYMBOL = 6,
    VT_TYPE = 8,
    VT_CURRENCY = 10,
    VT_TICKSIZENANOS = 12,
    VT_TICKSIZETICKS = 14,
    VT_LOTSIZELOTS = 16,
    VT_META = 18
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const ::flatbuffers::String *symbol() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SYMBOL);
  }
  ctc::InstrType type() const {
    return static_cast<ctc::InstrType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::String *currency() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CURRENCY);
  }
  uint32_t tickSizeNanos() const {
    return GetField<uint32_t>(VT_TICKSIZENANOS, 0);
  }
  uint32_t tickSizeTicks() const {
    return GetField<uint32_t>(VT_TICKSIZETICKS, 0);
  }
  uint32_t lotSizeLots() const {
    return GetField<uint32_t>(VT_LOTSIZELOTS, 0);
  }
  uint64_t meta() const {
    return GetField<uint64_t>(VT_META, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_CURRENCY) &&
           verifier.VerifyString(currency()) &&
           VerifyField<uint32_t>(verifier, VT_TICKSIZENANOS, 4) &&
           VerifyField<uint32_t>(verifier, VT_TICKSIZETICKS, 4) &&
           VerifyField<uint32_t>(verifier, VT_LOTSIZELOTS, 4) &&
           VerifyField<uint64_t>(verifier, VT_META, 8) &&
           verifier.EndTable();
  }
};

struct InstrumentBuilder {
  typedef Instrument Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(Instrument::VT_ID, id, 0);
  }
  void add_symbol(::flatbuffers::Offset<::flatbuffers::String> symbol) {
    fbb_.AddOffset(Instrument::VT_SYMBOL, symbol);
  }
  void add_type(ctc::InstrType type) {
    fbb_.AddElement<uint8_t>(Instrument::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_currency(::flatbuffers::Offset<::flatbuffers::String> currency) {
    fbb_.AddOffset(Instrument::VT_CURRENCY, currency);
  }
  void add_tickSizeNanos(uint32_t tickSizeNanos) {
    fbb_.AddElement<uint32_t>(Instrument::VT_TICKSIZENANOS, tickSizeNanos, 0);
  }
  void add_tickSizeTicks(uint32_t tickSizeTicks) {
    fbb_.AddElement<uint32_t>(Instrument::VT_TICKSIZETICKS, tickSizeTicks, 0);
  }
  void add_lotSizeLots(uint32_t lotSizeLots) {
    fbb_.AddElement<uint32_t>(Instrument::VT_LOTSIZELOTS, lotSizeLots, 0);
  }
  void add_meta(uint64_t meta) {
    fbb_.AddElement<uint64_t>(Instrument::VT_META, meta, 0);
  }
  explicit InstrumentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Instrument> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Instrument>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Instrument> CreateInstrument(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> symbol = 0,
    ctc::InstrType type = ctc::InstrType_Equity,
    ::flatbuffers::Offset<::flatbuffers::String> currency = 0,
    uint32_t tickSizeNanos = 0,
    uint32_t tickSizeTicks = 0,
    uint32_t lotSizeLots = 0,
    uint64_t meta = 0) {
  InstrumentBuilder builder_(_fbb);
  builder_.add_meta(meta);
  builder_.add_lotSizeLots(lotSizeLots);
  builder_.add_tickSizeTicks(tickSizeTicks);
  builder_.add_tickSizeNanos(tickSizeNanos);
  builder_.add_currency(currency);
  builder_.add_symbol(symbol);
  builder_.add_id(id);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Instrument> CreateInstrumentDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const char *symbol = nullptr,
    ctc::InstrType type = ctc::InstrType_Equity,
    const char *currency = nullptr,
    uint32_t tickSizeNanos = 0,
    uint32_t tickSizeTicks = 0,
    uint32_t lotSizeLots = 0,
    uint64_t meta = 0) {
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto currency__ = currency ? _fbb.CreateString(currency) : 0;
  return ctc::CreateInstrument(
      _fbb,
      id,
      symbol__,
      type,
      currency__,
      tickSizeNanos,
      tickSizeTicks,
      lotSizeLots,
      meta);
}

struct EtfComponent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EtfComponentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ETFINSTRUMENTID = 4,
    VT_COMPONENTINSTRUMENTID = 6,
    VT_WEIGHTNUM = 8,
    VT_WEIGHTDEN = 10
  };
  uint32_t etfInstrumentId() const {
    return GetField<uint32_t>(VT_ETFINSTRUMENTID, 0);
  }
  uint32_t componentInstrumentId() const {
    return GetField<uint32_t>(VT_COMPONENTINSTRUMENTID, 0);
  }
  int32_t weightNum() const {
    return GetField<int32_t>(VT_WEIGHTNUM, 0);
  }
  int32_t weightDen() const {
    return GetField<int32_t>(VT_WEIGHTDEN, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ETFINSTRUMENTID, 4) &&
           VerifyField<uint32_t>(verifier, VT_COMPONENTINSTRUMENTID, 4) &&
           VerifyField<int32_t>(verifier, VT_WEIGHTNUM, 4) &&
           VerifyField<int32_t>(verifier, VT_WEIGHTDEN, 4) &&
           verifier.EndTable();
  }
};

struct EtfComponentBuilder {
  typedef EtfComponent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_etfInstrumentId(uint32_t etfInstrumentId) {
    fbb_.AddElement<uint32_t>(EtfComponent::VT_ETFINSTRUMENTID, etfInstrumentId, 0);
  }
  void add_componentInstrumentId(uint32_t componentInstrumentId) {
    fbb_.AddElement<uint32_t>(EtfComponent::VT_COMPONENTINSTRUMENTID, componentInstrumentId, 0);
  }
  void add_weightNum(int32_t weightNum) {
    fbb_.AddElement<int32_t>(EtfComponent::VT_WEIGHTNUM, weightNum, 0);
  }
  void add_weightDen(int32_t weightDen) {
    fbb_.AddElement<int32_t>(EtfComponent::VT_WEIGHTDEN, weightDen, 0);
  }
  explicit EtfComponentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EtfComponent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EtfComponent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EtfComponent> CreateEtfComponent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t etfInstrumentId = 0,
    uint32_t componentInstrumentId = 0,
    int32_t weightNum = 0,
    int32_t weightDen = 0) {
  EtfComponentBuilder builder_(_fbb);
  builder_.add_weightDen(weightDen);
  builder_.add_weightNum(weightNum);
  builder_.add_componentInstrumentId(componentInstrumentId);
  builder_.add_etfInstrumentId(etfInstrumentId);
  return builder_.Finish();
}

struct OptionMeta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OptionMetaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTRUMENTID = 4,
    VT_UNDERLYINGINSTRUMENTID = 6,
    VT_STRIKETICKS = 8,
    VT_RIGHT = 10,
    VT_EXPIRYEPOCHDAYS = 12,
    VT_MULTIPLIER = 14
  };
  uint32_t instrumentId() const {
    return GetField<uint32_t>(VT_INSTRUMENTID, 0);
  }
  uint32_t underlyingInstrumentId() const {
    return GetField<uint32_t>(VT_UNDERLYINGINSTRUMENTID, 0);
  }
  int32_t strikeTicks() const {
    return GetField<int32_t>(VT_STRIKETICKS, 0);
  }
  uint8_t right() const {
    return GetField<uint8_t>(VT_RIGHT, 0);
  }
  uint32_t expiryEpochDays() const {
    return GetField<uint32_t>(VT_EXPIRYEPOCHDAYS, 0);
  }
  uint32_t multiplier() const {
    return GetField<uint32_t>(VT_MULTIPLIER, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_INSTRUMENTID, 4) &&
           VerifyField<uint32_t>(verifier, VT_UNDERLYINGINSTRUMENTID, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIKETICKS, 4) &&
           VerifyField<uint8_t>(verifier, VT_RIGHT, 1) &&
           VerifyField<uint32_t>(verifier, VT_EXPIRYEPOCHDAYS, 4) &&
           VerifyField<uint32_t>(verifier, VT_MULTIPLIER, 4) &&
           verifier.EndTable();
  }
};

struct OptionMetaBuilder {
  typedef OptionMeta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_instrumentId(uint32_t instrumentId) {
    fbb_.AddElement<uint32_t>(OptionMeta::VT_INSTRUMENTID, instrumentId, 0);
  }
  void add_underlyingInstrumentId(uint32_t underlyingInstrumentId) {
    fbb_.AddElement<uint32_t>(OptionMeta::VT_UNDERLYINGINSTRUMENTID, underlyingInstrumentId, 0);
  }
  void add_strikeTicks(int32_t strikeTicks) {
    fbb_.AddElement<int32_t>(OptionMeta::VT_STRIKETICKS, strikeTicks, 0);
  }
  void add_right(uint8_t right) {
    fbb_.AddElement<uint8_t>(OptionMeta::VT_RIGHT, right, 0);
  }
  void add_expiryEpochDays(uint32_t expiryEpochDays) {
    fbb_.AddElement<uint32_t>(OptionMeta::VT_EXPIRYEPOCHDAYS, expiryEpochDays, 0);
  }
  void add_multiplier(uint32_t multiplier) {
    fbb_.AddElement<uint32_t>(OptionMeta::VT_MULTIPLIER, multiplier, 0);
  }
  explicit OptionMetaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OptionMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OptionMeta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OptionMeta> CreateOptionMeta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t instrumentId = 0,
    uint32_t underlyingInstrumentId = 0,
    int32_t strikeTicks = 0,
    uint8_t right = 0,
    uint32_t expiryEpochDays = 0,
    uint32_t multiplier = 0) {
  OptionMetaBuilder builder_(_fbb);
  builder_.add_multiplier(multiplier);
  builder_.add_expiryEpochDays(expiryEpochDays);
  builder_.add_strikeTicks(strikeTicks);
  builder_.add_underlyingInstrumentId(underlyingInstrumentId);
  builder_.add_instrumentId(instrumentId);
  builder_.add_right(right);
  return builder_.Finish();
}

struct ConfigSnapshot FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConfigSnapshotBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_INSTRUMENTS = 6,
    VT_ETF = 8,
    VT_OPTIONS = 10,
    VT_RISKLIMITS = 12,
    VT_TSNANOS = 14
  };
  uint64_t version() const {
    return GetField<uint64_t>(VT_VERSION, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ctc::Instrument>> *instruments() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ctc::Instrument>> *>(VT_INSTRUMENTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ctc::EtfComponent>> *etf() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ctc::EtfComponent>> *>(VT_ETF);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ctc::OptionMeta>> *options() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ctc::OptionMeta>> *>(VT_OPTIONS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ctc::RiskLimit>> *riskLimits() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ctc::RiskLimit>> *>(VT_RISKLIMITS);
  }
  uint64_t tsNanos() const {
    return GetField<uint64_t>(VT_TSNANOS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_VERSION, 8) &&
           VerifyOffset(verifier, VT_INSTRUMENTS) &&
           verifier.VerifyVector(instruments()) &&
           verifier.VerifyVectorOfTables(instruments()) &&
           VerifyOffset(verifier, VT_ETF) &&
           verifier.VerifyVector(etf()) &&
           verifier.VerifyVectorOfTables(etf()) &&
           VerifyOffset(verifier, VT_OPTIONS) &&
           verifier.VerifyVector(options()) &&
           verifier.VerifyVectorOfTables(options()) &&
           VerifyOffset(verifier, VT_RISKLIMITS) &&
           verifier.VerifyVector(riskLimits()) &&
           verifier.VerifyVectorOfTables(riskLimits()) &&
           VerifyField<uint64_t>(verifier, VT_TSNANOS, 8) &&
           verifier.EndTable();
  }
};

struct ConfigSnapshotBuilder {
  typedef ConfigSnapshot Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version(uint64_t version) {
    fbb_.AddElement<uint64_t>(ConfigSnapshot::VT_VERSION, version, 0);
  }
  void add_instruments(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ctc::Instrument>>> instruments) {
    fbb_.AddOffset(ConfigSnapshot::VT_INSTRUMENTS, instruments);
  }
  void add_etf(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ctc::EtfComponent>>> etf) {
    fbb_.AddOffset(ConfigSnapshot::VT_ETF, etf);
  }
  void add_options(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ctc::OptionMeta>>> options) {
    fbb_.AddOffset(ConfigSnapshot::VT_OPTIONS, options);
  }
  void add_riskLimits(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ctc::RiskLimit>>> riskLimits) {
    fbb_.AddOffset(ConfigSnapshot::VT_RISKLIMITS, riskLimits);
  }
  void add_tsNanos(uint64_t tsNanos) {
    fbb_.AddElement<uint64_t>(ConfigSnapshot::VT_TSNANOS, tsNanos, 0);
  }
  explicit ConfigSnapshotBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConfigSnapshot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConfigSnapshot>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConfigSnapshot> CreateConfigSnapshot(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t version = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ctc::Instrument>>> instruments = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ctc::EtfComponent>>> etf = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ctc::OptionMeta>>> options = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ctc::RiskLimit>>> riskLimits = 0,
    uint64_t tsNanos = 0) {
  ConfigSnapshotBuilder builder_(_fbb);
  builder_.add_tsNanos(tsNanos);
  builder_.add_version(version);
  builder_.add_riskLimits(riskLimits);
  builder_.add_options(options);
  builder_.add_etf(etf);
  builder_.add_instruments(instruments);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ConfigSnapshot> CreateConfigSnapshotDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t version = 0,
    const std::vector<::flatbuffers::Offset<ctc::Instrument>> *instruments = nullptr,
    const std::vector<::flatbuffers::Offset<ctc::EtfComponent>> *etf = nullptr,
    const std::vector<::flatbuffers::Offset<ctc::OptionMeta>> *options = nullptr,
    const std::vector<::flatbuffers::Offset<ctc::RiskLimit>> *riskLimits = nullptr,
    uint64_t tsNanos = 0) {
  auto instruments__ = instruments ? _fbb.CreateVector<::flatbuffers::Offset<ctc::Instrument>>(*instruments) : 0;
  auto etf__ = etf ? _fbb.CreateVector<::flatbuffers::Offset<ctc::EtfComponent>>(*etf) : 0;
  auto options__ = options ? _fbb.CreateVector<::flatbuffers::Offset<ctc::OptionMeta>>(*options) : 0;
  auto riskLimits__ = riskLimits ? _fbb.CreateVector<::flatbuffers::Offset<ctc::RiskLimit>>(*riskLimits) : 0;
  return ctc::CreateConfigSnapshot(
      _fbb,
      version,
      instruments__,
      etf__,
      options__,
      riskLimits__,
      tsNanos);
}

struct OrderNew FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OrderNewBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLORDID = 4,
    VT_INSTRUMENTID = 6,
    VT_SIDE = 8,
    VT_TYPE = 10,
    VT_TIF = 12,
    VT_PXTICKS = 14,
    VT_LOTS = 16,
    VT_MINFILLLOTS = 18,
    VT_POSTONLY = 20,
    VT_STP = 22,
    VT_USERID = 24,
    VT_TEAMID = 26
  };
  uint64_t clOrdId() const {
    return GetField<uint64_t>(VT_CLORDID, 0);
  }
  uint32_t instrumentId() const {
    return GetField<uint32_t>(VT_INSTRUMENTID, 0);
  }
  ctc::Side side() const {
    return static_cast<ctc::Side>(GetField<uint8_t>(VT_SIDE, 0));
  }
  ctc::OrderType type() const {
    return static_cast<ctc::OrderType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  ctc::TIF tif() const {
    return static_cast<ctc::TIF>(GetField<uint8_t>(VT_TIF, 0));
  }
  int32_t pxTicks() const {
    return GetField<int32_t>(VT_PXTICKS, 0);
  }
  int64_t lots() const {
    return GetField<int64_t>(VT_LOTS, 0);
  }
  int64_t minFillLots() const {
    return GetField<int64_t>(VT_MINFILLLOTS, 0);
  }
  bool postOnly() const {
    return GetField<uint8_t>(VT_POSTONLY, 0) != 0;
  }
  ctc::StpMode stp() const {
    return static_cast<ctc::StpMode>(GetField<uint8_t>(VT_STP, 0));
  }
  uint32_t userId() const {
    return GetField<uint32_t>(VT_USERID, 0);
  }
  uint32_t teamId() const {
    return GetField<uint32_t>(VT_TEAMID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CLORDID, 8) &&
           VerifyField<uint32_t>(verifier, VT_INSTRUMENTID, 4) &&
           VerifyField<uint8_t>(verifier, VT_SIDE, 1) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_TIF, 1) &&
           VerifyField<int32_t>(verifier, VT_PXTICKS, 4) &&
           VerifyField<int64_t>(verifier, VT_LOTS, 8) &&
           VerifyField<int64_t>(verifier, VT_MINFILLLOTS, 8) &&
           VerifyField<uint8_t>(verifier, VT_POSTONLY, 1) &&
           VerifyField<uint8_t>(verifier, VT_STP, 1) &&
           VerifyField<uint32_t>(verifier, VT_USERID, 4) &&
           VerifyField<uint32_t>(verifier, VT_TEAMID, 4) &&
           verifier.EndTable();
  }
};

struct OrderNewBuilder {
  typedef OrderNew Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_clOrdId(uint64_t clOrdId) {
    fbb_.AddElement<uint64_t>(OrderNew::VT_CLORDID, clOrdId, 0);
  }
  void add_instrumentId(uint32_t instrumentId) {
    fbb_.AddElement<uint32_t>(OrderNew::VT_INSTRUMENTID, instrumentId, 0);
  }
  void add_side(ctc::Side side) {
    fbb_.AddElement<uint8_t>(OrderNew::VT_SIDE, static_cast<uint8_t>(side), 0);
  }
  void add_type(ctc::OrderType type) {
    fbb_.AddElement<uint8_t>(OrderNew::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_tif(ctc::TIF tif) {
    fbb_.AddElement<uint8_t>(OrderNew::VT_TIF, static_cast<uint8_t>(tif), 0);
  }
  void add_pxTicks(int32_t pxTicks) {
    fbb_.AddElement<int32_t>(OrderNew::VT_PXTICKS, pxTicks, 0);
  }
  void add_lots(int64_t lots) {
    fbb_.AddElement<int64_t>(OrderNew::VT_LOTS, lots, 0);
  }
  void add_minFillLots(int64_t minFillLots) {
    fbb_.AddElement<int64_t>(OrderNew::VT_MINFILLLOTS, minFillLots, 0);
  }
  void add_postOnly(bool postOnly) {
    fbb_.AddElement<uint8_t>(OrderNew::VT_POSTONLY, static_cast<uint8_t>(postOnly), 0);
  }
  void add_stp(ctc::StpMode stp) {
    fbb_.AddElement<uint8_t>(OrderNew::VT_STP, static_cast<uint8_t>(stp), 0);
  }
  void add_userId(uint32_t userId) {
    fbb_.AddElement<uint32_t>(OrderNew::VT_USERID, userId, 0);
  }
  void add_teamId(uint32_t teamId) {
    fbb_.AddElement<uint32_t>(OrderNew::VT_TEAMID, teamId, 0);
  }
  explicit OrderNewBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OrderNew> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OrderNew>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OrderNew> CreateOrderNew(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t clOrdId = 0,
    uint32_t instrumentId = 0,
    ctc::Side side = ctc::Side_Buy,
    ctc::OrderType type = ctc::OrderType_Limit,
    ctc::TIF tif = ctc::TIF_GFD,
    int32_t pxTicks = 0,
    int64_t lots = 0,
    int64_t minFillLots = 0,
    bool postOnly = false,
    ctc::StpMode stp = ctc::StpMode_None,
    uint32_t userId = 0,
    uint32_t teamId = 0) {
  OrderNewBuilder builder_(_fbb);
  builder_.add_minFillLots(minFillLots);
  builder_.add_lots(lots);
  builder_.add_clOrdId(clOrdId);
  builder_.add_teamId(teamId);
  builder_.add_userId(userId);
  builder_.add_pxTicks(pxTicks);
  builder_.add_instrumentId(instrumentId);
  builder_.add_stp(stp);
  builder_.add_postOnly(postOnly);
  builder_.add_tif(tif);
  builder_.add_type(type);
  builder_.add_side(side);
  return builder_.Finish();
}

struct OrderReplace FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OrderReplaceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORIGCLORDID = 4,
    VT_NEWCLORDID = 6,
    VT_INSTRUMENTID = 8,
    VT_PXTICKS = 10,
    VT_LOTS = 12,
    VT_MINFILLLOTS = 14,
    VT_POSTONLY = 16,
    VT_USERID = 18,
    VT_TEAMID = 20
  };
  uint64_t origClOrdId() const {
    return GetField<uint64_t>(VT_ORIGCLORDID, 0);
  }
  uint64_t newClOrdId() const {
    return GetField<uint64_t>(VT_NEWCLORDID, 0);
  }
  uint32_t instrumentId() const {
    return GetField<uint32_t>(VT_INSTRUMENTID, 0);
  }
  int32_t pxTicks() const {
    return GetField<int32_t>(VT_PXTICKS, 0);
  }
  int64_t lots() const {
    return GetField<int64_t>(VT_LOTS, 0);
  }
  int64_t minFillLots() const {
    return GetField<int64_t>(VT_MINFILLLOTS, 0);
  }
  bool postOnly() const {
    return GetField<uint8_t>(VT_POSTONLY, 0) != 0;
  }
  uint32_t userId() const {
    return GetField<uint32_t>(VT_USERID, 0);
  }
  uint32_t teamId() const {
    return GetField<uint32_t>(VT_TEAMID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ORIGCLORDID, 8) &&
           VerifyField<uint64_t>(verifier, VT_NEWCLORDID, 8) &&
           VerifyField<uint32_t>(verifier, VT_INSTRUMENTID, 4) &&
           VerifyField<int32_t>(verifier, VT_PXTICKS, 4) &&
           VerifyField<int64_t>(verifier, VT_LOTS, 8) &&
           VerifyField<int64_t>(verifier, VT_MINFILLLOTS, 8) &&
           VerifyField<uint8_t>(verifier, VT_POSTONLY, 1) &&
           VerifyField<uint32_t>(verifier, VT_USERID, 4) &&
           VerifyField<uint32_t>(verifier, VT_TEAMID, 4) &&
           verifier.EndTable();
  }
};

struct OrderReplaceBuilder {
  typedef OrderReplace Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_origClOrdId(uint64_t origClOrdId) {
    fbb_.AddElement<uint64_t>(OrderReplace::VT_ORIGCLORDID, origClOrdId, 0);
  }
  void add_newClOrdId(uint64_t newClOrdId) {
    fbb_.AddElement<uint64_t>(OrderReplace::VT_NEWCLORDID, newClOrdId, 0);
  }
  void add_instrumentId(uint32_t instrumentId) {
    fbb_.AddElement<uint32_t>(OrderReplace::VT_INSTRUMENTID, instrumentId, 0);
  }
  void add_pxTicks(int32_t pxTicks) {
    fbb_.AddElement<int32_t>(OrderReplace::VT_PXTICKS, pxTicks, 0);
  }
  void add_lots(int64_t lots) {
    fbb_.AddElement<int64_t>(OrderReplace::VT_LOTS, lots, 0);
  }
  void add_minFillLots(int64_t minFillLots) {
    fbb_.AddElement<int64_t>(OrderReplace::VT_MINFILLLOTS, minFillLots, 0);
  }
  void add_postOnly(bool postOnly) {
    fbb_.AddElement<uint8_t>(OrderReplace::VT_POSTONLY, static_cast<uint8_t>(postOnly), 0);
  }
  void add_userId(uint32_t userId) {
    fbb_.AddElement<uint32_t>(OrderReplace::VT_USERID, userId, 0);
  }
  void add_teamId(uint32_t teamId) {
    fbb_.AddElement<uint32_t>(OrderReplace::VT_TEAMID, teamId, 0);
  }
  explicit OrderReplaceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OrderReplace> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OrderReplace>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OrderReplace> CreateOrderReplace(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t origClOrdId = 0,
    uint64_t newClOrdId = 0,
    uint32_t instrumentId = 0,
    int32_t pxTicks = 0,
    int64_t lots = 0,
    int64_t minFillLots = 0,
    bool postOnly = false,
    uint32_t userId = 0,
    uint32_t teamId = 0) {
  OrderReplaceBuilder builder_(_fbb);
  builder_.add_minFillLots(minFillLots);
  builder_.add_lots(lots);
  builder_.add_newClOrdId(newClOrdId);
  builder_.add_origClOrdId(origClOrdId);
  builder_.add_teamId(teamId);
  builder_.add_userId(userId);
  builder_.add_pxTicks(pxTicks);
  builder_.add_instrumentId(instrumentId);
  builder_.add_postOnly(postOnly);
  return builder_.Finish();
}

struct OrderCancel FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OrderCancelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLORDID = 4,
    VT_INSTRUMENTID = 6,
    VT_USERID = 8,
    VT_TEAMID = 10
  };
  uint64_t clOrdId() const {
    return GetField<uint64_t>(VT_CLORDID, 0);
  }
  uint32_t instrumentId() const {
    return GetField<uint32_t>(VT_INSTRUMENTID, 0);
  }
  uint32_t userId() const {
    return GetField<uint32_t>(VT_USERID, 0);
  }
  uint32_t teamId() const {
    return GetField<uint32_t>(VT_TEAMID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CLORDID, 8) &&
           VerifyField<uint32_t>(verifier, VT_INSTRUMENTID, 4) &&
           VerifyField<uint32_t>(verifier, VT_USERID, 4) &&
           VerifyField<uint32_t>(verifier, VT_TEAMID, 4) &&
           verifier.EndTable();
  }
};

struct OrderCancelBuilder {
  typedef OrderCancel Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_clOrdId(uint64_t clOrdId) {
    fbb_.AddElement<uint64_t>(OrderCancel::VT_CLORDID, clOrdId, 0);
  }
  void add_instrumentId(uint32_t instrumentId) {
    fbb_.AddElement<uint32_t>(OrderCancel::VT_INSTRUMENTID, instrumentId, 0);
  }
  void add_userId(uint32_t userId) {
    fbb_.AddElement<uint32_t>(OrderCancel::VT_USERID, userId, 0);
  }
  void add_teamId(uint32_t teamId) {
    fbb_.AddElement<uint32_t>(OrderCancel::VT_TEAMID, teamId, 0);
  }
  explicit OrderCancelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OrderCancel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OrderCancel>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OrderCancel> CreateOrderCancel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t clOrdId = 0,
    uint32_t instrumentId = 0,
    uint32_t userId = 0,
    uint32_t teamId = 0) {
  OrderCancelBuilder builder_(_fbb);
  builder_.add_clOrdId(clOrdId);
  builder_.add_teamId(teamId);
  builder_.add_userId(userId);
  builder_.add_instrumentId(instrumentId);
  return builder_.Finish();
}

struct CancelAll FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CancelAllBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCOPE = 4,
    VT_USERID = 6,
    VT_TEAMID = 8
  };
  const ::flatbuffers::String *scope() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SCOPE);
  }
  uint32_t userId() const {
    return GetField<uint32_t>(VT_USERID, 0);
  }
  uint32_t teamId() const {
    return GetField<uint32_t>(VT_TEAMID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SCOPE) &&
           verifier.VerifyString(scope()) &&
           VerifyField<uint32_t>(verifier, VT_USERID, 4) &&
           VerifyField<uint32_t>(verifier, VT_TEAMID, 4) &&
           verifier.EndTable();
  }
};

struct CancelAllBuilder {
  typedef CancelAll Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_scope(::flatbuffers::Offset<::flatbuffers::String> scope) {
    fbb_.AddOffset(CancelAll::VT_SCOPE, scope);
  }
  void add_userId(uint32_t userId) {
    fbb_.AddElement<uint32_t>(CancelAll::VT_USERID, userId, 0);
  }
  void add_teamId(uint32_t teamId) {
    fbb_.AddElement<uint32_t>(CancelAll::VT_TEAMID, teamId, 0);
  }
  explicit CancelAllBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CancelAll> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CancelAll>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CancelAll> CreateCancelAll(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> scope = 0,
    uint32_t userId = 0,
    uint32_t teamId = 0) {
  CancelAllBuilder builder_(_fbb);
  builder_.add_teamId(teamId);
  builder_.add_userId(userId);
  builder_.add_scope(scope);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CancelAll> CreateCancelAllDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *scope = nullptr,
    uint32_t userId = 0,
    uint32_t teamId = 0) {
  auto scope__ = scope ? _fbb.CreateString(scope) : 0;
  return ctc::CreateCancelAll(
      _fbb,
      scope__,
      userId,
      teamId);
}

struct Ack FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AckBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXECTYPE = 4,
    VT_CLORDID = 6,
    VT_ORDERID = 8,
    VT_INSTRUMENTID = 10,
    VT_FILLEDLOTS = 12,
    VT_LEAVESLOTS = 14,
    VT_AVGPXTICKS = 16,
    VT_REJECTCODE = 18,
    VT_TEXT = 20,
    VT_TSNANOS = 22
  };
  ctc::ExecType execType() const {
    return static_cast<ctc::ExecType>(GetField<uint8_t>(VT_EXECTYPE, 0));
  }
  uint64_t clOrdId() const {
    return GetField<uint64_t>(VT_CLORDID, 0);
  }
  uint64_t orderId() const {
    return GetField<uint64_t>(VT_ORDERID, 0);
  }
  uint32_t instrumentId() const {
    return GetField<uint32_t>(VT_INSTRUMENTID, 0);
  }
  int64_t filledLots() const {
    return GetField<int64_t>(VT_FILLEDLOTS, 0);
  }
  int64_t leavesLots() const {
    return GetField<int64_t>(VT_LEAVESLOTS, 0);
  }
  int32_t avgPxTicks() const {
    return GetField<int32_t>(VT_AVGPXTICKS, 0);
  }
  ctc::RejectCode rejectCode() const {
    return static_cast<ctc::RejectCode>(GetField<uint16_t>(VT_REJECTCODE, 0));
  }
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  uint64_t tsNanos() const {
    return GetField<uint64_t>(VT_TSNANOS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EXECTYPE, 1) &&
           VerifyField<uint64_t>(verifier, VT_CLORDID, 8) &&
           VerifyField<uint64_t>(verifier, VT_ORDERID, 8) &&
           VerifyField<uint32_t>(verifier, VT_INSTRUMENTID, 4) &&
           VerifyField<int64_t>(verifier, VT_FILLEDLOTS, 8) &&
           VerifyField<int64_t>(verifier, VT_LEAVESLOTS, 8) &&
           VerifyField<int32_t>(verifier, VT_AVGPXTICKS, 4) &&
           VerifyField<uint16_t>(verifier, VT_REJECTCODE, 2) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyField<uint64_t>(verifier, VT_TSNANOS, 8) &&
           verifier.EndTable();
  }
};

struct AckBuilder {
  typedef Ack Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_execType(ctc::ExecType execType) {
    fbb_.AddElement<uint8_t>(Ack::VT_EXECTYPE, static_cast<uint8_t>(execType), 0);
  }
  void add_clOrdId(uint64_t clOrdId) {
    fbb_.AddElement<uint64_t>(Ack::VT_CLORDID, clOrdId, 0);
  }
  void add_orderId(uint64_t orderId) {
    fbb_.AddElement<uint64_t>(Ack::VT_ORDERID, orderId, 0);
  }
  void add_instrumentId(uint32_t instrumentId) {
    fbb_.AddElement<uint32_t>(Ack::VT_INSTRUMENTID, instrumentId, 0);
  }
  void add_filledLots(int64_t filledLots) {
    fbb_.AddElement<int64_t>(Ack::VT_FILLEDLOTS, filledLots, 0);
  }
  void add_leavesLots(int64_t leavesLots) {
    fbb_.AddElement<int64_t>(Ack::VT_LEAVESLOTS, leavesLots, 0);
  }
  void add_avgPxTicks(int32_t avgPxTicks) {
    fbb_.AddElement<int32_t>(Ack::VT_AVGPXTICKS, avgPxTicks, 0);
  }
  void add_rejectCode(ctc::RejectCode rejectCode) {
    fbb_.AddElement<uint16_t>(Ack::VT_REJECTCODE, static_cast<uint16_t>(rejectCode), 0);
  }
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(Ack::VT_TEXT, text);
  }
  void add_tsNanos(uint64_t tsNanos) {
    fbb_.AddElement<uint64_t>(Ack::VT_TSNANOS, tsNanos, 0);
  }
  explicit AckBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Ack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Ack>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Ack> CreateAck(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ctc::ExecType execType = ctc::ExecType_Ack,
    uint64_t clOrdId = 0,
    uint64_t orderId = 0,
    uint32_t instrumentId = 0,
    int64_t filledLots = 0,
    int64_t leavesLots = 0,
    int32_t avgPxTicks = 0,
    ctc::RejectCode rejectCode = ctc::RejectCode_None,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0,
    uint64_t tsNanos = 0) {
  AckBuilder builder_(_fbb);
  builder_.add_tsNanos(tsNanos);
  builder_.add_leavesLots(leavesLots);
  builder_.add_filledLots(filledLots);
  builder_.add_orderId(orderId);
  builder_.add_clOrdId(clOrdId);
  builder_.add_text(text);
  builder_.add_avgPxTicks(avgPxTicks);
  builder_.add_instrumentId(instrumentId);
  builder_.add_rejectCode(rejectCode);
  builder_.add_execType(execType);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Ack> CreateAckDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ctc::ExecType execType = ctc::ExecType_Ack,
    uint64_t clOrdId = 0,
    uint64_t orderId = 0,
    uint32_t instrumentId = 0,
    int64_t filledLots = 0,
    int64_t leavesLots = 0,
    int32_t avgPxTicks = 0,
    ctc::RejectCode rejectCode = ctc::RejectCode_None,
    const char *text = nullptr,
    uint64_t tsNanos = 0) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return ctc::CreateAck(
      _fbb,
      execType,
      clOrdId,
      orderId,
      instrumentId,
      filledLots,
      leavesLots,
      avgPxTicks,
      rejectCode,
      text__,
      tsNanos);
}

struct ETFCreateRedeem FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ETFCreateRedeemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REQUESTID = 4,
    VT_ETFINSTRUMENTID = 6,
    VT_LOTS = 8,
    VT_USERID = 10,
    VT_TEAMID = 12
  };
  uint64_t requestId() const {
    return GetField<uint64_t>(VT_REQUESTID, 0);
  }
  uint32_t etfInstrumentId() const {
    return GetField<uint32_t>(VT_ETFINSTRUMENTID, 0);
  }
  int64_t lots() const {
    return GetField<int64_t>(VT_LOTS, 0);
  }
  uint32_t userId() const {
    return GetField<uint32_t>(VT_USERID, 0);
  }
  uint32_t teamId() const {
    return GetField<uint32_t>(VT_TEAMID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_REQUESTID, 8) &&
           VerifyField<uint32_t>(verifier, VT_ETFINSTRUMENTID, 4) &&
           VerifyField<int64_t>(verifier, VT_LOTS, 8) &&
           VerifyField<uint32_t>(verifier, VT_USERID, 4) &&
           VerifyField<uint32_t>(verifier, VT_TEAMID, 4) &&
           verifier.EndTable();
  }
};

struct ETFCreateRedeemBuilder {
  typedef ETFCreateRedeem Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_requestId(uint64_t requestId) {
    fbb_.AddElement<uint64_t>(ETFCreateRedeem::VT_REQUESTID, requestId, 0);
  }
  void add_etfInstrumentId(uint32_t etfInstrumentId) {
    fbb_.AddElement<uint32_t>(ETFCreateRedeem::VT_ETFINSTRUMENTID, etfInstrumentId, 0);
  }
  void add_lots(int64_t lots) {
    fbb_.AddElement<int64_t>(ETFCreateRedeem::VT_LOTS, lots, 0);
  }
  void add_userId(uint32_t userId) {
    fbb_.AddElement<uint32_t>(ETFCreateRedeem::VT_USERID, userId, 0);
  }
  void add_teamId(uint32_t teamId) {
    fbb_.AddElement<uint32_t>(ETFCreateRedeem::VT_TEAMID, teamId, 0);
  }
  explicit ETFCreateRedeemBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ETFCreateRedeem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ETFCreateRedeem>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ETFCreateRedeem> CreateETFCreateRedeem(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t requestId = 0,
    uint32_t etfInstrumentId = 0,
    int64_t lots = 0,
    uint32_t userId = 0,
    uint32_t teamId = 0) {
  ETFCreateRedeemBuilder builder_(_fbb);
  builder_.add_lots(lots);
  builder_.add_requestId(requestId);
  builder_.add_teamId(teamId);
  builder_.add_userId(userId);
  builder_.add_etfInstrumentId(etfInstrumentId);
  return builder_.Finish();
}

struct EtfLeg FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EtfLegBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTRUMENTID = 4,
    VT_LOTS = 6
  };
  uint32_t instrumentId() const {
    return GetField<uint32_t>(VT_INSTRUMENTID, 0);
  }
  int64_t lots() const {
    return GetField<int64_t>(VT_LOTS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_INSTRUMENTID, 4) &&
           VerifyField<int64_t>(verifier, VT_LOTS, 8) &&
           verifier.EndTable();
  }
};

struct EtfLegBuilder {
  typedef EtfLeg Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_instrumentId(uint32_t instrumentId) {
    fbb_.AddElement<uint32_t>(EtfLeg::VT_INSTRUMENTID, instrumentId, 0);
  }
  void add_lots(int64_t lots) {
    fbb_.AddElement<int64_t>(EtfLeg::VT_LOTS, lots, 0);
  }
  explicit EtfLegBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EtfLeg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EtfLeg>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EtfLeg> CreateEtfLeg(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t instrumentId = 0,
    int64_t lots = 0) {
  EtfLegBuilder builder_(_fbb);
  builder_.add_lots(lots);
  builder_.add_instrumentId(instrumentId);
  return builder_.Finish();
}

struct ETFCreateRedeemResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ETFCreateRedeemResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REQUESTID = 4,
    VT_ETFINSTRUMENTID = 6,
    VT_LOTS = 8,
    VT_LEGS = 10,
    VT_SUCCESS = 12,
    VT_REJECTCODE = 14,
    VT_TEXT = 16,
    VT_TSNANOS = 18
  };
  uint64_t requestId() const {
    return GetField<uint64_t>(VT_REQUESTID, 0);
  }
  uint32_t etfInstrumentId() const {
    return GetField<uint32_t>(VT_ETFINSTRUMENTID, 0);
  }
  int64_t lots() const {
    return GetField<int64_t>(VT_LOTS, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ctc::EtfLeg>> *legs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ctc::EtfLeg>> *>(VT_LEGS);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  ctc::RejectCode rejectCode() const {
    return static_cast<ctc::RejectCode>(GetField<uint16_t>(VT_REJECTCODE, 0));
  }
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  uint64_t tsNanos() const {
    return GetField<uint64_t>(VT_TSNANOS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_REQUESTID, 8) &&
           VerifyField<uint32_t>(verifier, VT_ETFINSTRUMENTID, 4) &&
           VerifyField<int64_t>(verifier, VT_LOTS, 8) &&
           VerifyOffset(verifier, VT_LEGS) &&
           verifier.VerifyVector(legs()) &&
           verifier.VerifyVectorOfTables(legs()) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyField<uint16_t>(verifier, VT_REJECTCODE, 2) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyField<uint64_t>(verifier, VT_TSNANOS, 8) &&
           verifier.EndTable();
  }
};

struct ETFCreateRedeemResultBuilder {
  typedef ETFCreateRedeemResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_requestId(uint64_t requestId) {
    fbb_.AddElement<uint64_t>(ETFCreateRedeemResult::VT_REQUESTID, requestId, 0);
  }
  void add_etfInstrumentId(uint32_t etfInstrumentId) {
    fbb_.AddElement<uint32_t>(ETFCreateRedeemResult::VT_ETFINSTRUMENTID, etfInstrumentId, 0);
  }
  void add_lots(int64_t lots) {
    fbb_.AddElement<int64_t>(ETFCreateRedeemResult::VT_LOTS, lots, 0);
  }
  void add_legs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ctc::EtfLeg>>> legs) {
    fbb_.AddOffset(ETFCreateRedeemResult::VT_LEGS, legs);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(ETFCreateRedeemResult::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_rejectCode(ctc::RejectCode rejectCode) {
    fbb_.AddElement<uint16_t>(ETFCreateRedeemResult::VT_REJECTCODE, static_cast<uint16_t>(rejectCode), 0);
  }
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(ETFCreateRedeemResult::VT_TEXT, text);
  }
  void add_tsNanos(uint64_t tsNanos) {
    fbb_.AddElement<uint64_t>(ETFCreateRedeemResult::VT_TSNANOS, tsNanos, 0);
  }
  explicit ETFCreateRedeemResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ETFCreateRedeemResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ETFCreateRedeemResult>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ETFCreateRedeemResult> CreateETFCreateRedeemResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t requestId = 0,
    uint32_t etfInstrumentId = 0,
    int64_t lots = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ctc::EtfLeg>>> legs = 0,
    bool success = false,
    ctc::RejectCode rejectCode = ctc::RejectCode_None,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0,
    uint64_t tsNanos = 0) {
  ETFCreateRedeemResultBuilder builder_(_fbb);
  builder_.add_tsNanos(tsNanos);
  builder_.add_lots(lots);
  builder_.add_requestId(requestId);
  builder_.add_text(text);
  builder_.add_legs(legs);
  builder_.add_etfInstrumentId(etfInstrumentId);
  builder_.add_rejectCode(rejectCode);
  builder_.add_success(success);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ETFCreateRedeemResult> CreateETFCreateRedeemResultDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t requestId = 0,
    uint32_t etfInstrumentId = 0,
    int64_t lots = 0,
    const std::vector<::flatbuffers::Offset<ctc::EtfLeg>> *legs = nullptr,
    bool success = false,
    ctc::RejectCode rejectCode = ctc::RejectCode_None,
    const char *text = nullptr,
    uint64_t tsNanos = 0) {
  auto legs__ = legs ? _fbb.CreateVector<::flatbuffers::Offset<ctc::EtfLeg>>(*legs) : 0;
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return ctc::CreateETFCreateRedeemResult(
      _fbb,
      requestId,
      etfInstrumentId,
      lots,
      legs__,
      success,
      rejectCode,
      text__,
      tsNanos);
}

struct Subscribe FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SubscribeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTRUMENTS = 4,
    VT_BOOKDEPTH = 6,
    VT_TRADES = 8,
    VT_POSITIONS = 10,
    VT_TEAMID = 12
  };
  const ::flatbuffers::Vector<uint32_t> *instruments() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_INSTRUMENTS);
  }
  uint16_t bookDepth() const {
    return GetField<uint16_t>(VT_BOOKDEPTH, 0);
  }
  bool trades() const {
    return GetField<uint8_t>(VT_TRADES, 0) != 0;
  }
  bool positions() const {
    return GetField<uint8_t>(VT_POSITIONS, 0) != 0;
  }
  uint32_t teamId() const {
    return GetField<uint32_t>(VT_TEAMID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INSTRUMENTS) &&
           verifier.VerifyVector(instruments()) &&
           VerifyField<uint16_t>(verifier, VT_BOOKDEPTH, 2) &&
           VerifyField<uint8_t>(verifier, VT_TRADES, 1) &&
           VerifyField<uint8_t>(verifier, VT_POSITIONS, 1) &&
           VerifyField<uint32_t>(verifier, VT_TEAMID, 4) &&
           verifier.EndTable();
  }
};

struct SubscribeBuilder {
  typedef Subscribe Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_instruments(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> instruments) {
    fbb_.AddOffset(Subscribe::VT_INSTRUMENTS, instruments);
  }
  void add_bookDepth(uint16_t bookDepth) {
    fbb_.AddElement<uint16_t>(Subscribe::VT_BOOKDEPTH, bookDepth, 0);
  }
  void add_trades(bool trades) {
    fbb_.AddElement<uint8_t>(Subscribe::VT_TRADES, static_cast<uint8_t>(trades), 0);
  }
  void add_positions(bool positions) {
    fbb_.AddElement<uint8_t>(Subscribe::VT_POSITIONS, static_cast<uint8_t>(positions), 0);
  }
  void add_teamId(uint32_t teamId) {
    fbb_.AddElement<uint32_t>(Subscribe::VT_TEAMID, teamId, 0);
  }
  explicit SubscribeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Subscribe> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Subscribe>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Subscribe> CreateSubscribe(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> instruments = 0,
    uint16_t bookDepth = 0,
    bool trades = false,
    bool positions = false,
    uint32_t teamId = 0) {
  SubscribeBuilder builder_(_fbb);
  builder_.add_teamId(teamId);
  builder_.add_instruments(instruments);
  builder_.add_bookDepth(bookDepth);
  builder_.add_positions(positions);
  builder_.add_trades(trades);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Subscribe> CreateSubscribeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *instruments = nullptr,
    uint16_t bookDepth = 0,
    bool trades = false,
    bool positions = false,
    uint32_t teamId = 0) {
  auto instruments__ = instruments ? _fbb.CreateVector<uint32_t>(*instruments) : 0;
  return ctc::CreateSubscribe(
      _fbb,
      instruments__,
      bookDepth,
      trades,
      positions,
      teamId);
}

struct Unsubscribe FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UnsubscribeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTRUMENTS = 4,
    VT_TEAMID = 6
  };
  const ::flatbuffers::Vector<uint32_t> *instruments() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_INSTRUMENTS);
  }
  uint32_t teamId() const {
    return GetField<uint32_t>(VT_TEAMID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INSTRUMENTS) &&
           verifier.VerifyVector(instruments()) &&
           VerifyField<uint32_t>(verifier, VT_TEAMID, 4) &&
           verifier.EndTable();
  }
};

struct UnsubscribeBuilder {
  typedef Unsubscribe Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_instruments(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> instruments) {
    fbb_.AddOffset(Unsubscribe::VT_INSTRUMENTS, instruments);
  }
  void add_teamId(uint32_t teamId) {
    fbb_.AddElement<uint32_t>(Unsubscribe::VT_TEAMID, teamId, 0);
  }
  explicit UnsubscribeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Unsubscribe> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Unsubscribe>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Unsubscribe> CreateUnsubscribe(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> instruments = 0,
    uint32_t teamId = 0) {
  UnsubscribeBuilder builder_(_fbb);
  builder_.add_teamId(teamId);
  builder_.add_instruments(instruments);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Unsubscribe> CreateUnsubscribeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *instruments = nullptr,
    uint32_t teamId = 0) {
  auto instruments__ = instruments ? _fbb.CreateVector<uint32_t>(*instruments) : 0;
  return ctc::CreateUnsubscribe(
      _fbb,
      instruments__,
      teamId);
}

struct Heartbeat FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HeartbeatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NONCE = 4
  };
  uint64_t nonce() const {
    return GetField<uint64_t>(VT_NONCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_NONCE, 8) &&
           verifier.EndTable();
  }
};

struct HeartbeatBuilder {
  typedef Heartbeat Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nonce(uint64_t nonce) {
    fbb_.AddElement<uint64_t>(Heartbeat::VT_NONCE, nonce, 0);
  }
  explicit HeartbeatBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Heartbeat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Heartbeat>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Heartbeat> CreateHeartbeat(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t nonce = 0) {
  HeartbeatBuilder builder_(_fbb);
  builder_.add_nonce(nonce);
  return builder_.Finish();
}

struct Auth FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AuthBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_JWT = 4,
    VT_CLIENTNAME = 6,
    VT_PROTOCOL = 8
  };
  const ::flatbuffers::String *jwt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_JWT);
  }
  const ::flatbuffers::String *clientName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLIENTNAME);
  }
  uint32_t protocol() const {
    return GetField<uint32_t>(VT_PROTOCOL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_JWT) &&
           verifier.VerifyString(jwt()) &&
           VerifyOffset(verifier, VT_CLIENTNAME) &&
           verifier.VerifyString(clientName()) &&
           VerifyField<uint32_t>(verifier, VT_PROTOCOL, 4) &&
           verifier.EndTable();
  }
};

struct AuthBuilder {
  typedef Auth Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_jwt(::flatbuffers::Offset<::flatbuffers::String> jwt) {
    fbb_.AddOffset(Auth::VT_JWT, jwt);
  }
  void add_clientName(::flatbuffers::Offset<::flatbuffers::String> clientName) {
    fbb_.AddOffset(Auth::VT_CLIENTNAME, clientName);
  }
  void add_protocol(uint32_t protocol) {
    fbb_.AddElement<uint32_t>(Auth::VT_PROTOCOL, protocol, 0);
  }
  explicit AuthBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Auth> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Auth>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Auth> CreateAuth(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> jwt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> clientName = 0,
    uint32_t protocol = 0) {
  AuthBuilder builder_(_fbb);
  builder_.add_protocol(protocol);
  builder_.add_clientName(clientName);
  builder_.add_jwt(jwt);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Auth> CreateAuthDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *jwt = nullptr,
    const char *clientName = nullptr,
    uint32_t protocol = 0) {
  auto jwt__ = jwt ? _fbb.CreateString(jwt) : 0;
  auto clientName__ = clientName ? _fbb.CreateString(clientName) : 0;
  return ctc::CreateAuth(
      _fbb,
      jwt__,
      clientName__,
      protocol);
}

struct Message FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCHEMAVERSION = 4,
    VT_PAYLOAD_TYPE = 6,
    VT_PAYLOAD = 8
  };
  uint16_t schemaVersion() const {
    return GetField<uint16_t>(VT_SCHEMAVERSION, 0);
  }
  ctc::Payload payload_type() const {
    return static_cast<ctc::Payload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const ctc::Auth *payload_as_Auth() const {
    return payload_type() == ctc::Payload_Auth ? static_cast<const ctc::Auth *>(payload()) : nullptr;
  }
  const ctc::Subscribe *payload_as_Subscribe() const {
    return payload_type() == ctc::Payload_Subscribe ? static_cast<const ctc::Subscribe *>(payload()) : nullptr;
  }
  const ctc::Unsubscribe *payload_as_Unsubscribe() const {
    return payload_type() == ctc::Payload_Unsubscribe ? static_cast<const ctc::Unsubscribe *>(payload()) : nullptr;
  }
  const ctc::Heartbeat *payload_as_Heartbeat() const {
    return payload_type() == ctc::Payload_Heartbeat ? static_cast<const ctc::Heartbeat *>(payload()) : nullptr;
  }
  const ctc::OrderNew *payload_as_OrderNew() const {
    return payload_type() == ctc::Payload_OrderNew ? static_cast<const ctc::OrderNew *>(payload()) : nullptr;
  }
  const ctc::OrderReplace *payload_as_OrderReplace() const {
    return payload_type() == ctc::Payload_OrderReplace ? static_cast<const ctc::OrderReplace *>(payload()) : nullptr;
  }
  const ctc::OrderCancel *payload_as_OrderCancel() const {
    return payload_type() == ctc::Payload_OrderCancel ? static_cast<const ctc::OrderCancel *>(payload()) : nullptr;
  }
  const ctc::CancelAll *payload_as_CancelAll() const {
    return payload_type() == ctc::Payload_CancelAll ? static_cast<const ctc::CancelAll *>(payload()) : nullptr;
  }
  const ctc::ETFCreateRedeem *payload_as_ETFCreateRedeem() const {
    return payload_type() == ctc::Payload_ETFCreateRedeem ? static_cast<const ctc::ETFCreateRedeem *>(payload()) : nullptr;
  }
  const ctc::Ack *payload_as_Ack() const {
    return payload_type() == ctc::Payload_Ack ? static_cast<const ctc::Ack *>(payload()) : nullptr;
  }
  const ctc::Trade *payload_as_Trade() const {
    return payload_type() == ctc::Payload_Trade ? static_cast<const ctc::Trade *>(payload()) : nullptr;
  }
  const ctc::BookDelta *payload_as_BookDelta() const {
    return payload_type() == ctc::Payload_BookDelta ? static_cast<const ctc::BookDelta *>(payload()) : nullptr;
  }
  const ctc::PositionUpdate *payload_as_PositionUpdate() const {
    return payload_type() == ctc::Payload_PositionUpdate ? static_cast<const ctc::PositionUpdate *>(payload()) : nullptr;
  }
  const ctc::ConfigSnapshot *payload_as_ConfigSnapshot() const {
    return payload_type() == ctc::Payload_ConfigSnapshot ? static_cast<const ctc::ConfigSnapshot *>(payload()) : nullptr;
  }
  const ctc::SessionEvent *payload_as_SessionEvent() const {
    return payload_type() == ctc::Payload_SessionEvent ? static_cast<const ctc::SessionEvent *>(payload()) : nullptr;
  }
  const ctc::ETFCreateRedeemResult *payload_as_ETFCreateRedeemResult() const {
    return payload_type() == ctc::Payload_ETFCreateRedeemResult ? static_cast<const ctc::ETFCreateRedeemResult *>(payload()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_SCHEMAVERSION, 2) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE, 1) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           VerifyPayload(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
};

template<> inline const ctc::Auth *Message::payload_as<ctc::Auth>() const {
  return payload_as_Auth();
}

template<> inline const ctc::Subscribe *Message::payload_as<ctc::Subscribe>() const {
  return payload_as_Subscribe();
}

template<> inline const ctc::Unsubscribe *Message::payload_as<ctc::Unsubscribe>() const {
  return payload_as_Unsubscribe();
}

template<> inline const ctc::Heartbeat *Message::payload_as<ctc::Heartbeat>() const {
  return payload_as_Heartbeat();
}

template<> inline const ctc::OrderNew *Message::payload_as<ctc::OrderNew>() const {
  return payload_as_OrderNew();
}

template<> inline const ctc::OrderReplace *Message::payload_as<ctc::OrderReplace>() const {
  return payload_as_OrderReplace();
}

template<> inline const ctc::OrderCancel *Message::payload_as<ctc::OrderCancel>() const {
  return payload_as_OrderCancel();
}

template<> inline const ctc::CancelAll *Message::payload_as<ctc::CancelAll>() const {
  return payload_as_CancelAll();
}

template<> inline const ctc::ETFCreateRedeem *Message::payload_as<ctc::ETFCreateRedeem>() const {
  return payload_as_ETFCreateRedeem();
}

template<> inline const ctc::Ack *Message::payload_as<ctc::Ack>() const {
  return payload_as_Ack();
}

template<> inline const ctc::Trade *Message::payload_as<ctc::Trade>() const {
  return payload_as_Trade();
}

template<> inline const ctc::BookDelta *Message::payload_as<ctc::BookDelta>() const {
  return payload_as_BookDelta();
}

template<> inline const ctc::PositionUpdate *Message::payload_as<ctc::PositionUpdate>() const {
  return payload_as_PositionUpdate();
}

template<> inline const ctc::ConfigSnapshot *Message::payload_as<ctc::ConfigSnapshot>() const {
  return payload_as_ConfigSnapshot();
}

template<> inline const ctc::SessionEvent *Message::payload_as<ctc::SessionEvent>() const {
  return payload_as_SessionEvent();
}

template<> inline const ctc::ETFCreateRedeemResult *Message::payload_as<ctc::ETFCreateRedeemResult>() const {
  return payload_as_ETFCreateRedeemResult();
}

struct MessageBuilder {
  typedef Message Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_schemaVersion(uint16_t schemaVersion) {
    fbb_.AddElement<uint16_t>(Message::VT_SCHEMAVERSION, schemaVersion, 0);
  }
  void add_payload_type(ctc::Payload payload_type) {
    fbb_.AddElement<uint8_t>(Message::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(::flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(Message::VT_PAYLOAD, payload);
  }
  explicit MessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Message> CreateMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t schemaVersion = 0,
    ctc::Payload payload_type = ctc::Payload_NONE,
    ::flatbuffers::Offset<void> payload = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_schemaVersion(schemaVersion);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

inline bool VerifyPayload(::flatbuffers::Verifier &verifier, const void *obj, Payload type) {
  switch (type) {
    case Payload_NONE: {
      return true;
    }
    case Payload_Auth: {
      auto ptr = reinterpret_cast<const ctc::Auth *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_Subscribe: {
      auto ptr = reinterpret_cast<const ctc::Subscribe *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_Unsubscribe: {
      auto ptr = reinterpret_cast<const ctc::Unsubscribe *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_Heartbeat: {
      auto ptr = reinterpret_cast<const ctc::Heartbeat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_OrderNew: {
      auto ptr = reinterpret_cast<const ctc::OrderNew *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_OrderReplace: {
      auto ptr = reinterpret_cast<const ctc::OrderReplace *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_OrderCancel: {
      auto ptr = reinterpret_cast<const ctc::OrderCancel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_CancelAll: {
      auto ptr = reinterpret_cast<const ctc::CancelAll *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_ETFCreateRedeem: {
      auto ptr = reinterpret_cast<const ctc::ETFCreateRedeem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_Ack: {
      auto ptr = reinterpret_cast<const ctc::Ack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_Trade: {
      auto ptr = reinterpret_cast<const ctc::Trade *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_BookDelta: {
      auto ptr = reinterpret_cast<const ctc::BookDelta *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_PositionUpdate: {
      auto ptr = reinterpret_cast<const ctc::PositionUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_ConfigSnapshot: {
      auto ptr = reinterpret_cast<const ctc::ConfigSnapshot *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_SessionEvent: {
      auto ptr = reinterpret_cast<const ctc::SessionEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_ETFCreateRedeemResult: {
      auto ptr = reinterpret_cast<const ctc::ETFCreateRedeemResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPayload(
        verifier,  values->Get(i), types->GetEnum<Payload>(i))) {
      return false;
    }
  }
  return true;
}

inline const ctc::Message *GetMessage(const void *buf) {
  return ::flatbuffers::GetRoot<ctc::Message>(buf);
}

inline const ctc::Message *GetSizePrefixedMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ctc::Message>(buf);
}

inline const char *MessageIdentifier() {
  return "CTC1";
}

inline bool MessageBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, MessageIdentifier());
}

inline bool SizePrefixedMessageBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, MessageIdentifier(), true);
}

inline bool VerifyMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ctc::Message>(MessageIdentifier());
}

inline bool VerifySizePrefixedMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ctc::Message>(MessageIdentifier());
}

inline void FinishMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ctc::Message> root) {
  fbb.Finish(root, MessageIdentifier());
}

inline void FinishSizePrefixedMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ctc::Message> root) {
  fbb.FinishSizePrefixed(root, MessageIdentifier());
}

}  // namespace ctc

#endif  // FLATBUFFERS_GENERATED_ENVELOPE_CTC_H_
